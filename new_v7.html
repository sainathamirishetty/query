<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title> Discussion Summary </title>
    <link rel="icon" href="/static/logo.png" type="image/png">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
            display: flex;
        }

        /* Session Sidebar */
        .sidebar {
            width: 280px;
            background: white;
            border-radius: 20px 0 0 20px;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        .sidebar h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        .new-session-btn {
            width: 100%;
            padding: 12px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            margin-bottom: 20px;
            transition: all 0.3s;
        }
        .new-session-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }
        .session-list {
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }
        .session-item {
            position: relative;
            padding: 12px;
            margin-bottom: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border-left: 4px solid transparent;
        }
        .session-item:hover {
            background: #e3f2fd;
            border-left-color: #667eea;
        }
        .session-item.active {
            background: #e3f2fd;
            border-left-color: #667eea;
        }
        .session-item-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }
        .session-item-meta {
            font-size: 0.85em;
            color: #666;
        }
        .session-item-count {
            font-size: 0.8em;
            color: #667eea;
            margin-top: 4px;
        }
        .session-item-count {
            font-size: 0.8em;
            color: #667eea;
            margin-top: 4px;
        }

        /* NEW: Toggle Buttons for Personal/Project */
        .view-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .toggle-btn {
            flex: 1;
            padding: 10px;
            background: #f0f0f0;
            color: #666;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            text-align: center;
        }
        .toggle-btn:hover {
            background: #e8e8e8;
        }
        .toggle-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        /* NEW: Project Items */
        .project-item {
            padding: 15px;
            margin-bottom: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border-left: 4px solid transparent;
        }
        .project-item:hover {
            background: #e3f2fd;
            border-left-color: #667eea;
        }
        .project-item.active {
            background: #e3f2fd;
            border-left-color: #667eea;
        }
        .project-item-name {
            font-weight: 600;
            color: #333;
            font-size: 1.1em;
        }
        .project-item-badge {
            display: inline-block;
            background: #28a745;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7em;
            margin-left: 8px;
        }

        /* ADD THESE NEW STYLES HERE */
        .session-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .session-item-content {
            flex: 1;
            min-width: 0;
        }

        .session-options-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 18px;
            padding: 4px 8px;
            color: #666;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .session-options-btn:hover {
            background: #e0e0e0;
            color: #333;
        }

        .session-menu {
            position: absolute;
            right: 10px;
            top: 40px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 1000;
            min-width: 140px;
            overflow: hidden;
        }

        .session-menu-item {
            padding: 12px 16px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 14px;
            color: #333;
        }

        .session-menu-item:hover {
            background: #f5f5f5;
        }

        .session-menu-item:not(:last-child) {
            border-bottom: 1px solid #eee;
        }

        .session-menu-item.delete {
            color: #dc3545;
        }

        .session-menu-item.delete:hover {
            background: #fff5f5;
        }
        /* END OF NEW STYLES */

        /* Main Container */
        .container {
            flex: 1;
            background: white;
            border-radius: 0 20px 20px 0;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .back-btn {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid white;
            padding: 8px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        .back-btn:hover {
            background: white;
            color: #667eea;
        }
        .content { padding: 30px; overflow-y: auto; max-height: calc(100vh - 160px); }
        .section {
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        .form-group { margin-bottom: 15px; }
        .date-time {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: flex-start;
        }
        .date-time > label {
            display: inline-block;
            margin-right: 6px;
            white-space: nowrap;
            font-weight: 600;
        }
        .date-time > input[type="date"],
        .date-time > input[type="time"] {
            width: 120px;
            padding: 8px 10px;
        }
        .date-time > input[type="text"] {
            flex: 1;
            min-width: 250px;
            padding: 8px 10px;
        }
        @media (max-width: 420px) {
            .date-time {
                flex-direction: column;
                align-items: stretch;
            }
            .date-time > input[type="date"],
            .date-time > input[type="time"] {
                width: 100%;
            }
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }
        input, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
        }
        input:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        .radio-group {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .radio-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: normal;
            cursor: pointer;
        }
        .radio-group input[type="radio"] {
            width: auto;
            cursor: pointer;
        }
        button {
            padding: 12px 25px;
            font-size: 15px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
        }
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary { background: #667eea; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-info { background: #17a2b8; color: white; }
        .btn-warning { background: #ffc107; color: #333; }
        .status-box {
            background: #1a1a1a;
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            height: 150px;
            overflow-y: auto;
            font-size: 13px;
        }
        .status-box p { margin: 3px 0; }
        .result-item {
            background: white;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }
        .result-header h3 {
            color: #667eea;
            margin: 0;
            font-size: 1.4em;
        }
        .result-content {
            line-height: 1.8;
            color: #333;
            font-size: 15px;
        }
        .result-content h4 {
            color: #667eea;
            margin-top: 20px;
            margin-bottom: 12px;
            font-size: 1.2em;
            font-weight: 600;
            padding-bottom: 8px;
            border-bottom: 2px solid #e0e0e0;
        }
        .result-content p {
            margin-bottom: 15px;
            text-align: justify;
            text-justify: inter-word;
        }
        .result-content ul, .result-content ol {
            margin-left: 25px;
            margin-bottom: 15px;
            margin-top: 10px;
        }
        .result-content li {
            margin-bottom: 8px;
            line-height: 1.6;
        }
        .result-content .action-item {
            margin-bottom: 12px;
            line-height: 1.6;
            padding-left: 0;
        }
        .result-content .action-item::before {
            content: '‚û§ ';
            color: #667eea;
            font-weight: bold;
            margin-right: 8px;
        }
        .recording-indicator {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: #fff3cd;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #ffc107;
        }
        .recording-indicator.active { display: flex; }
        .pulse {
            width: 12px;
            height: 12px;
            background: #dc3545;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }
        .timer {
            font-weight: 600;
            color: #dc3545;
            font-size: 1.1em;
        }
        .chunk-timer {
            font-weight: 600;
            color: #667eea;
            font-size: 0.9em;
            margin-left: auto;
        }
        .button-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        .mode-info {
            background: #e3f2fd;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #2196f3;
            font-size: 13px;
            color: #1565c0;
        }
        .current-mode-display {
            background: #4caf50;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: bold;
            text-align: center;
            font-size: 14px;
        }
        .session-info-banner {
            background: #4caf50;
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: bold;
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- Session Sidebar -->
    <div class="sidebar">
        <h2>üìÇ Sessions</h2>
        
        <!-- NEW: View Toggle Buttons -->
        <div class="view-toggle">
            <button class="toggle-btn active" id="personalBtn" onclick="showPersonalView()">
                üë§ Personal
            </button>
            <button class="toggle-btn" id="projectBtn" onclick="showProjectView()">
                üìÅ Projects
            </button>
        </div>

        <!-- Personal View -->
        <div id="personalView">
            <button class="new-session-btn" onclick="createNewSession()">+ New Session</button>
            <div class="session-list" id="sessionList">
                <p style="color: #999; text-align: center;">Loading sessions...</p>
            </div>
        </div>

        <!-- Project View -->
        <div id="projectView" style="display: none;">
            <div class="session-list" id="projectsList">
                <!-- Projects will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Main Container -->
    <div class="container">
        <div class="header">
            <button class="back-btn" onclick="goBack()">‚Üê Back</button>
            <h1>üìù Discussion Summary </h1>
        </div>

        <div class="content">
            <!-- Session Info Banner -->
            <div class="session-info-banner" id="sessionBanner" style="display:none;">
                No session selected - Click "+ New Session" to start
            </div>

            <!-- Meeting Info -->
            <div class="section">
                <h2>üìã Meeting Information</h2>
                <div class="form-group date-time">
                    <label for="date">Date:</label>
                    <input type="date" id="date">

                    <label for="time">Time:</label>
                    <input type="time" id="time">

                    <label for="venue">Venue:</label>
                    <input type="text" id="venue" placeholder="Enter meeting venue">
                </div>
                <div class="form-group">
                    <label>Agenda:</label>
                    <textarea id="agenda" rows="3" placeholder=""></textarea>
                </div>
            </div>

            <!-- Processing Mode -->
            <div class="section">
                <h2>‚öôÔ∏è Processing Mode</h2>

                <div class="current-mode-display" id="currentModeDisplay" style="display:none;">
                    Current Active Mode: Not Started
                </div>
                <div class="form-group">
                    <label>Select Mode:</label>
                    <div class="radio-group">
                        <label>
                            <input type="radio" name="mode" value="Summary" id="modeSummary" checked>
                            Summary
                        </label>
                        <label>
                            <input type="radio" name="mode" value="Action Points" id="modeActionPoints">
                            Action Points
                        </label>
                    </div>
                </div>
                <div class="form-group" id="summaryLengthGroup">
                    <label>Summary Length:</label>
                    <div class="radio-group">
                        <label>
                            <input type="radio" name="summaryLength" value="Short" id="lengthShort" checked>
                            Short
                        </label>
                        <label>
                            <input type="radio" name="summaryLength" value="Medium" id="lengthMedium">
                            Medium
                        </label>
                        <label>
                            <input type="radio" name="summaryLength" value="Long" id="lengthLong">
                            Long
                        </label>
                    </div>
                </div>
            </div>

            <!-- Recording Controls -->
            <div class="section">
                <h2>üé§ Recording Controls</h2>
                <div class="recording-indicator" id="recIndicator">
                    <div class="pulse"></div>
                    <span>Recording in progress...</span>
                    <span class="timer" id="timer">00:00:00</span>
                    <span class="chunk-timer" id="chunkTimer"></span>
                </div>

                <div class="button-row">
                    <button class="btn-primary" id="startBtn" onclick="startRec()">Start Meeting</button>
                    <button class="btn-warning" id="pauseBtn" onclick="pauseRec()" disabled>Pause Meeting</button>
                    <button class="btn-danger" id="stopBtn" onclick="endMeeting()" disabled>End Meeting</button>
                </div>

                <div class="button-row">
                    <button class="btn-info" onclick="uploadFile()">Upload Audio File</button>
                    <button class="btn-primary" onclick="genGlobalSummary()">Generate Global Summary</button>
                    <button class="btn-success" onclick="saveResults()">Save Results (.doc)</button>
                </div>

                <input type="file" id="fileInput" accept=".wav,.webm,.mp3,.m4a,.ogg" style="display:none" onchange="handleFile(event)">
            </div>

            <!-- Status -->
            <div class="section" style="display:none;">
                <h2>üìä Status</h2>
                <div class="status-box" id="status"></div>
            </div>

            <!-- Results -->
            <div class="section" id="resultsSection" style="display:none;">
                <h2>üìÑ Results</h2>
                <div id="results"></div>
            </div>
        </div>
    </div>

    <script>
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let isPaused = false;
        let startTime = null;
        let timerInterval = null;
        let chunkTimerInterval = null;
        let pausedTime = 0;
        let pauseStartTime = null;
        let serverUrl = '';
        let allResults = [];

        // Session management
        let currentSessionId = null;
        let resultOrderCounter = 0;
        let userSessions = [];

        // NEW: Project management
        let currentView = 'personal'; // 'personal' or 'project'
        let currentProjectId = null;
        
        // Hardcoded 4 projects
        const PROJECTS = [
            { project_id: 'project_1', project_name: 'Project 1' },
            { project_id: 'project_2', project_name: 'Project 2' },
            { project_id: 'project_3', project_name: 'Project 3' },
            { project_id: 'project_4', project_name: 'Project 4' }
        ];

        // Track the last mode type (Summary or Action Points) to detect mode switches
        let lastModeType = null;

        let currentMimeType = 'audio/webm';
        let lastChunkTime = null;
        let autoChunkInterval = null;
        let audioContext = null;
        let scriptProcessor = null;
        let audioInput = null;
        let bufferData = [];
        let chunkCounter = 0;
        let meetingStartTime = null;
        let mediaStreamRef = null;
        let isProcessingModeSwitch = false;

        function goBack() {
            window.location.href = '/';
        }

        document.addEventListener('DOMContentLoaded', async () => {
            const today = new Date();
            document.getElementById('date').valueAsDate = today;
            document.getElementById('time').value = today.toTimeString().slice(0, 5);

            // Listen to mode changes
            document.querySelectorAll('input[name="mode"]').forEach(radio => {
                radio.addEventListener('change', handleModeChange);
            });

            // Listen to metadata changes
            document.getElementById('date').addEventListener('change', saveMetadata);
            document.getElementById('time').addEventListener('change', saveMetadata);
            document.getElementById('venue').addEventListener('change', saveMetadata);
            document.getElementById('agenda').addEventListener('change', saveMetadata);

            checkServerSilently();
            await loadUserSessions();
        });

        async function loadUserSessions() {
            try {
                const response = await fetch('/user_discussion_sessions');
                const data = await response.json();

                if (data.status === 'success') {
                    userSessions = data.sessions;
                    renderSessionList();

                    // Auto-select most recent session
                    if (userSessions.length > 0) {
                        loadSession(userSessions[0].session_id);
                    } else {
                        updateSessionBanner('No sessions yet - Click "+ New Session" to start');
                    }
                } else {
                    log('‚úó Failed to load sessions');
                }
            } catch (error) {
                log('‚úó Error loading sessions: ' + error.message);
            }
        }

        function renderSessionList() {
    const sessionList = document.getElementById('sessionList');

    if (userSessions.length === 0) {
        sessionList.innerHTML = '<p style="color: #999; text-align: center;">No sessions yet</p>';
        return;
    }

    sessionList.innerHTML = '';
    userSessions.forEach(session => {
        const sessionItem = document.createElement('div');
        sessionItem.className = 'session-item';
        if (session.session_id === currentSessionId) {
            sessionItem.classList.add('active');
        }

        const name = session.session_name || 'Unnamed Session';
        const date = session.meeting_date || 'No date';
        const resultCount = session.result_count || 0;

        sessionItem.innerHTML = `
            <div class="session-item-header">
                <div class="session-item-content">
                    <div class="session-item-name">${name}</div>
                    <div class="session-item-meta">${date}</div>
                    <div class="session-item-count">${resultCount} result(s)</div>
                </div>
                <button class="session-options-btn" onclick="toggleSessionMenu('${session.session_id}', event)">
                    ‚ãÆ
                </button>
            </div>
        `;

        // Create menu (hidden by default)
        const menu = document.createElement('div');
        menu.id = `menu-${session.session_id}`;
        menu.className = 'session-menu';
        menu.style.display = 'none';
        menu.innerHTML = `
            <div class="session-menu-item" onclick="renameSession('${session.session_id}', event)">
                ‚úèÔ∏è Rename
            </div>
            <div class="session-menu-item delete" onclick="deleteSession('${session.session_id}', event)">
                üóëÔ∏è Delete
            </div>
        `;
        sessionItem.appendChild(menu);

        // Click on session item (not the button) to load it
        sessionItem.querySelector('.session-item-content').onclick = () => loadSession(session.session_id);

        sessionList.appendChild(sessionItem);
    });
}

        async function createNewSession() {
            try {
                const response = await fetch('/create_discussion_session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({
                        session_name: `Discussion - ${new Date().toLocaleString()}`,
                        session_type: 'personal'
                    })
                });

                const data = await response.json();

                if (data.status === 'success') {
                    log('‚úì New session created');
                    await loadUserSessions();
                    loadSession(data.session_id);
                } else {
                    alert('Failed to create session');
                }
            } catch (error) {
                log('‚úó Error creating session: ' + error.message);
                alert('Error creating session');
            }
        }

        async function loadSession(sessionId) {
    try {
        const response = await fetch(`/discussion_session/${sessionId}`);
        const data = await response.json();

        if (data.status === 'success') {
            const session = data.session;
            currentSessionId = sessionId;

            // Update metadata fields
            document.getElementById('date').value = session.meeting_date || '';
            document.getElementById('time').value = session.meeting_time || '';
            document.getElementById('venue').value = session.venue || '';
            document.getElementById('agenda').value = session.agenda || '';

            // CLEAR and reload results
            allResults = [];
            resultOrderCounter = 0;

            const resultsContainer = document.getElementById('results');
            resultsContainer.innerHTML = '';

            if (session.results.length > 0) {
                document.getElementById('resultsSection').style.display = 'block';
                session.results.forEach((result, index) => {
                    displayStoredResult(result, index + 1);
                    allResults.push({
                        mode: result.mode,
                        summaryLength: result.summary_length,
                        result: result.result_text,
                        timestamp: result.created_at
                    });
                });
                resultOrderCounter = session.results.length;
            } else {
                document.getElementById('resultsSection').style.display = 'none';
            }

            renderSessionList(); // Update active state
            updateSessionBanner(`Active Session: ${session.session_name || 'Unnamed Session'}`);
            log(`‚úì Loaded session: ${session.session_name || 'Unnamed'} with ${session.results.length} result(s)`);
        } else {
            alert('Failed to load session');
        }
    } catch (error) {
        log('‚úó Error loading session: ' + error.message);
        alert('Error loading session');
    }
}

        function displayStoredResult(result, resultNumber) {
            const resultsContainer = document.getElementById('results');

            const resultDiv = document.createElement('div');
            resultDiv.className = 'result-item';

            const header = document.createElement('div');
            header.className = 'result-header';

            const title = document.createElement('h3');

            if (result.mode === 'Summary' && result.summary_length) {
                title.textContent = `${resultNumber}. Summary (${result.summary_length})`;
            } else if (result.mode === 'GLOBAL SUMMARY') {
                title.textContent = `${resultNumber}. Global Summary`;
            } else {
                title.textContent = `${resultNumber}. ${result.mode}`;
            }

            header.appendChild(title);

            const content = document.createElement('div');
            content.className = 'result-content';

            const cleanText = result.result_text
                .replace(/\[SUMMARY[^\]]*\]\s*/g, '')
                .replace(/\[ACTION POINTS\]\s*/g, '')
                .replace(/\[GLOBAL SUMMARY\]\s*/g, '')
                .trim();

            content.innerHTML = formatTextToHTML(cleanText);

            resultDiv.appendChild(header);
            resultDiv.appendChild(content);

            resultsContainer.appendChild(resultDiv);
        }

        function updateSessionBanner(message) {
            const banner = document.getElementById('sessionBanner');
            banner.textContent = message;
            banner.style.display = 'block';
            banner.style.background = currentSessionId ? '#4caf50' : '#ffc107';
            banner.style.color = currentSessionId ? 'white' : '#333';
        }

        async function saveMetadata() {
            if (!currentSessionId) return;

            try {
                const response = await fetch('/update_session_metadata', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: currentSessionId,
                        meeting_date: document.getElementById('date').value,
                        meeting_time: document.getElementById('time').value,
                        venue: document.getElementById('venue').value,
                        agenda: document.getElementById('agenda').value
                    })
                });

                if (response.ok) {
                    log('‚úì Metadata saved');
                }
            } catch (error) {
                log('‚úó Error saving metadata: ' + error.message);
            }
        }

        async function checkServerSilently() {
            try {
                const response = await fetch(`${serverUrl}/health`);
                const data = await response.json();
                if (data.gpu_server?.status === 'healthy' && data.gpu_server?.model_loaded) {
                    log('‚úì Server connected and ready');
                } else {
                    log('‚ö† Server connected but model loading');
                }
            } catch (error) {
                log('‚úó Cannot connect to server: ' + error.message);
            }
        }

        function getCurrentModeFromUI() {
            const mode = document.querySelector('input[name="mode"]:checked').value;
            return mode;
        }

        function getCurrentSummaryLengthFromUI() {
            const lengthRadio = document.querySelector('input[name="summaryLength"]:checked');
            return lengthRadio ? lengthRadio.value : null;
        }

        function getFullModeFromUI() {
            const mode = getCurrentModeFromUI();
            if (mode === 'Summary') {
                const length = getCurrentSummaryLengthFromUI();
                if (!length) return null;
                return `Summary ${length}`;
            }
            return mode;
        }

        function handleModeChange() {
            const mode = getCurrentModeFromUI();
            const summaryLengthGroup = document.getElementById('summaryLengthGroup');

            summaryLengthGroup.style.display = mode === 'Summary' ? 'block' : 'none';

            // When switching back to Summary, default to Short
            if (mode === 'Summary') {
                document.getElementById('lengthShort').checked = true;
            }

            // If recording is active, check if we need to process mode switch
            if (isRecording && !isProcessingModeSwitch) {
                const currentModeType = mode;

                // Only process if we're switching between Summary and Action Points
                if (lastModeType && lastModeType !== currentModeType) {
                    log(`üîÑ Mode switch detected: ${lastModeType} ‚Üí ${currentModeType}`);
                    processModeSwitch(lastModeType, currentModeType);
                } else {
                    // Just a summary length change - do nothing, will be validated at next chunk
                    if (mode === 'Summary') {
                        const length = getCurrentSummaryLengthFromUI();
                        log(`üìè Summary length changed to: ${length} (will apply at next chunk)`);
                    }
                }
            }
        }

        async function startRec() {
            if (!currentSessionId) {
                alert('Please create or select a session first');
                return;
            }

            try {
                const mode = getCurrentModeFromUI();
                if (mode === 'Summary') {
                    const length = getCurrentSummaryLengthFromUI();
                    if (!length) {
                        alert('Please select a Summary Length (Short/Medium/Long) before starting the meeting.');
                        log('‚úó Cannot start: No summary length selected');
                        return;
                    }
                }

                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });
                mediaStreamRef = stream;

                isRecording = false;
                isPaused = false;
                startTime = null;
                pausedTime = 0;
                pauseStartTime = null;
                audioChunks = [];
                bufferData = [];

                // Set last mode type
                lastModeType = getCurrentModeFromUI();

                currentMimeType = 'audio/wav';

                const audioTrack = stream.getAudioTracks()[0];
                const settings = audioTrack.getSettings();
                const micSampleRate = settings.sampleRate || 48000;

                log(`üé§ Microphone sample rate: ${micSampleRate}Hz`);

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioInput = audioContext.createMediaStreamSource(stream);

                const bufferSize = 4096;
                scriptProcessor = audioContext.createScriptProcessor(bufferSize, 1, 1);

                scriptProcessor.onaudioprocess = function(e) {
                    if (!isPaused && isRecording) {
                        const inputData = e.inputBuffer.getChannelData(0);
                        const buffer = new Float32Array(inputData);
                        bufferData.push(buffer);
                    }
                };

                audioInput.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);

                isRecording = true;
                isPaused = false;
                startTime = Date.now();
                lastChunkTime = Date.now();
                pausedTime = 0;
                chunkCounter = 0;
                meetingStartTime = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);

                startTimer();
                startChunkTimer();
                startAutoChunking();

                document.getElementById('recIndicator').classList.add('active');
                document.getElementById('startBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('pauseBtn').textContent = 'Pause Meeting';
                document.getElementById('stopBtn').disabled = false;

                const fullMode = getFullModeFromUI();
                log('üéô Meeting started - Mode: ' + fullMode + ` (Recording at ${micSampleRate}Hz)`);

            } catch (error) {
                log('‚úó Error starting recording: ' + error.message);
                alert('Error accessing microphone: ' + error.message);
            }
        }

        function getChunkDuration() {
            return 300000; // 5 minutes
        }

        function startAutoChunking() {
            stopAutoChunking();
            const duration = getChunkDuration();

            autoChunkInterval = setInterval(() => {
                if (isRecording && !isPaused && !isProcessingModeSwitch) {
                    // Validate current UI mode at chunk time
                    const currentMode = getCurrentModeFromUI();
                    const currentLength = getCurrentSummaryLengthFromUI();
                    const fullMode = currentMode === 'Summary' ? `${currentMode} ${currentLength}` : currentMode;

                    log(`‚è± Auto-processing 5-minute chunk (Mode: ${fullMode})`);
                    processCurrentChunk();
                    lastChunkTime = Date.now();
                }
            }, duration);
        }

        function stopAutoChunking() {
            if (autoChunkInterval) {
                clearInterval(autoChunkInterval);
                autoChunkInterval = null;
            }
        }

        function startChunkTimer() {
            chunkTimerInterval = setInterval(() => {
                if (isRecording && !isPaused) {
                    const elapsed = Math.floor((Date.now() - lastChunkTime) / 1000);
                    const chunkDuration = getChunkDuration() / 1000;
                    const remaining = chunkDuration - elapsed;

                    if (remaining >= 0) {
                        const minutes = Math.floor(remaining / 60);
                        const seconds = remaining % 60;
                        const timeStr = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                        document.getElementById('chunkTimer').textContent = ``;
                    }
                } else {
                    document.getElementById('chunkTimer').textContent = '';
                }
            }, 1000);
        }

        function pauseRec() {
            if (!isRecording) {
                log('‚úó No active recording to pause');
                return;
            }

            if (isPaused) {
                isPaused = false;
                if (pauseStartTime) {
                    pausedTime += (Date.now() - pauseStartTime);
                    pauseStartTime = null;
                }
                document.getElementById('pauseBtn').textContent = 'Pause Meeting';
                log('‚ñ∂ Recording resumed');
            } else {
                isPaused = true;
                pauseStartTime = Date.now();
                document.getElementById('pauseBtn').textContent = 'Resume Meeting';
                log('‚è∏ Recording paused');
            }
        }

        async function processModeSwitch(oldModeType, newModeType) {
            if (isProcessingModeSwitch) {
                log('‚ö† Already processing a mode switch, please wait...');
                return;
            }

            isProcessingModeSwitch = true;

            // Get the old mode with current summary length (if applicable)
            let oldMode = oldModeType;
            let oldLength = null;
            if (oldModeType === 'Summary') {
                oldLength = getCurrentSummaryLengthFromUI();
            }

            const oldFullMode = oldMode === 'Summary' ? `${oldMode} ${oldLength}` : oldMode;
            log(`üîÑ Processing accumulated audio with OLD mode: ${oldFullMode}`);

            // Process with OLD mode
            await processCurrentChunkWithMode(oldMode, oldLength);

            // Update lastModeType to new mode
            lastModeType = newModeType;

            lastChunkTime = Date.now();

            const newFullMode = getFullModeFromUI();
            log(`‚úì Switched to ${newFullMode} - Timer reset, next chunk in 5 minutes`);

            stopAutoChunking();
            startAutoChunking();
            isProcessingModeSwitch = false;
        }

        async function processCurrentChunk() {
            // Always read current mode from UI
            const mode = getCurrentModeFromUI();
            const length = getCurrentSummaryLengthFromUI();
            await processCurrentChunkWithMode(mode, length);
        }

        async function processCurrentChunkWithMode(mode, summaryLength) {
            if (bufferData.length === 0) {
                log('‚ö† No audio to process');
                return;
            }

            const fullMode = mode === 'Summary' ? `${mode} ${summaryLength}` : mode;
            log(`üì§ Processing chunk with mode: ${fullMode}`);

            const chunksToProcess = [...bufferData];
            bufferData = [];

            let totalLength = 0;
            for (const chunk of chunksToProcess) {
                totalLength += chunk.length;
            }

            const mergedData = new Float32Array(totalLength);
            let offset = 0;
            for (const chunk of chunksToProcess) {
                mergedData.set(chunk, offset);
                offset += chunk.length;
            }

            const wavBlob = encodeWAV(mergedData, audioContext.sampleRate, 16000);
            const duration = (mergedData.length / audioContext.sampleRate).toFixed(2);
            log(`üìä WAV audio size: ${(wavBlob.size / 1024).toFixed(2)} KB, Duration: ${duration}s`);

            chunkCounter++;
            resultOrderCounter++;
            log('üì° Sending WAV audio to server');
            await sendAudioToServer(wavBlob, mode, summaryLength);
        }

        async function endMeeting() {
            if (!isRecording) {
                log('‚úó No active meeting to end');
                return;
            }

            log('üõë Ending meeting...');
            document.getElementById('stopBtn').disabled = true;
            log('‚è≥ Please wait - processing final audio chunk...');

            stopTimer();
            stopAutoChunking();
            if (chunkTimerInterval) {
                clearInterval(chunkTimerInterval);
                chunkTimerInterval = null;
            }

            isRecording = false;
            isPaused = false;

            try {
                if (bufferData.length > 0) {
                    // Validate current UI mode for final chunk
                    const mode = getCurrentModeFromUI();
                    const length = getCurrentSummaryLengthFromUI();
                    const fullMode = mode === 'Summary' ? `${mode} ${length}` : mode;
                    log(`üì§ Processing final audio chunk with mode: ${fullMode}`);
                    await processCurrentChunkAndWait(mode, length);
                    log('‚úì Final chunk processing complete!');
                } else {
                    log('‚Ñπ No remaining audio to process');
                }
            } catch (err) {
                log('‚úó Error while processing final chunk: ' + err.message);
            }

            try {
                if (scriptProcessor) {
                    scriptProcessor.onaudioprocess = null;
                    try { scriptProcessor.disconnect(); } catch(e){}
                    scriptProcessor = null;
                    log('‚úì Audio processing stopped');
                }

                if (audioInput) {
                    try { audioInput.disconnect(); } catch(e){}
                    audioInput = null;
                    log('‚úì Audio input disconnected');
                }

                if (mediaStreamRef) {
                    try {
                        mediaStreamRef.getTracks().forEach(track => {
                            try { track.stop(); } catch(e){}
                            log(`‚úì Stopped ${track.kind} track`);
                        });
                    } catch (e) {
                        log('‚úó Error stopping media tracks: ' + e.message);
                    }
                    mediaStreamRef = null;
                }

                if (audioContext && audioContext.state !== 'closed') {
                    try {
                        await audioContext.close();
                        audioContext = null;
                        log('‚úì AudioContext closed');
                    } catch (e) {
                        log('‚úó Error closing AudioContext: ' + e.message);
                    }
                }
            } catch (error) {
                log('‚úó Error cleaning up audio: ' + error.message);
            }

            document.getElementById('recIndicator').classList.remove('active');
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('pauseBtn').textContent = 'Pause Meeting';
            document.getElementById('timer').textContent = '00:00:00';
            document.getElementById('chunkTimer').textContent = '';

            bufferData = [];
            chunkCounter = 0;
            meetingStartTime = null;
            isPaused = false;
            pausedTime = 0;
            pauseStartTime = null;
            startTime = null;
            lastChunkTime = null;
            lastModeType = null;

            log('‚úÖ Meeting ended successfully - all processing complete!');

            // Reload session to get updated results
            if (currentSessionId) {
                await loadSession(currentSessionId);
            }
        }

        async function processCurrentChunkAndWait(mode, summaryLength) {
            if (bufferData.length === 0) {
                log('‚ö† No audio to process');
                return;
            }

            const fullMode = mode === 'Summary' ? `${mode} ${summaryLength}` : mode;
            log(`üì§ Processing final chunk with mode: ${fullMode}`);

            const chunksToProcess = [...bufferData];
            bufferData = [];

            let totalLength = 0;
            for (const chunk of chunksToProcess) {
                totalLength += chunk.length;
            }

            const mergedData = new Float32Array(totalLength);
            let offset = 0;
            for (const chunk of chunksToProcess) {
                mergedData.set(chunk, offset);
                offset += chunk.length;
            }

            const wavBlob = encodeWAV(mergedData, audioContext.sampleRate, 16000);
            const duration = (mergedData.length / audioContext.sampleRate).toFixed(2);
            log(`üìä WAV audio size: ${(wavBlob.size / 1024).toFixed(2)} KB, Duration: ${duration}s`);

            chunkCounter++;
            resultOrderCounter++;
            log('üì° Sending final WAV audio to server and waiting for completion...');
            await sendAudioToServerAndWait(wavBlob, mode, summaryLength);
        }

        function uploadFile() {
            if (!currentSessionId) {
                alert('Please create or select a session first');
                return;
            }
            document.getElementById('fileInput').click();
        }

        async function handleFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const mode = getCurrentModeFromUI();
            let summaryLength = null;

            if (mode === 'Summary') {
                summaryLength = getCurrentSummaryLengthFromUI();
                if (!summaryLength) {
                    log('‚úó Please select a summary length first');
                    alert('Please select a Summary Length (Short/Medium/Long) before uploading.');
                    event.target.value = '';
                    return;
                }
            }

            if (!mode) {
                log('‚úó Please select a processing mode first');
                alert('Please select a processing mode first');
                event.target.value = '';
                return;
            }

            const fullMode = mode === 'Summary' ? `${mode} ${summaryLength}` : mode;
            log(`üìÅ Uploading file: ${file.name} with mode: ${fullMode}`);
            resultOrderCounter++;
            await sendAudioToServer(file, mode, summaryLength, true);

            event.target.value = '';
        }

        async function sendAudioToServer(audioBlob, mode, summaryLength, isUpload = false) {
            const formData = new FormData();
            const filename = `chunk_${Date.now()}.wav`;

            formData.append('file', audioBlob, filename);
            formData.append('mode', mode);
            if (mode === 'Summary') {
                formData.append('summary_length', summaryLength);
            }
            formData.append('is_upload', isUpload ? 'true' : 'false');
            formData.append('session_id', currentSessionId);
            formData.append('result_order', resultOrderCounter.toString());

            try {
                const fullMode = mode === 'Summary' ? `${mode} ${summaryLength}` : mode;
                log(`üì§ Uploading WAV to server... (Mode: ${fullMode})`);

                const response = await fetch(`${serverUrl}/process_audio`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Server request failed');
                }

                const data = await response.json();
                log(`‚úì Job created: ${data.job_id.substring(0, 8)}... (${fullMode})`);

                pollJobStatus(data.job_id, mode, summaryLength);

            } catch (error) {
                log('‚úó Error sending audio: ' + error.message);
                alert('Error uploading audio: ' + error.message);
            }
        }

        async function sendAudioToServerAndWait(audioBlob, mode, summaryLength, isUpload = false) {
            const formData = new FormData();
            const filename = `chunk_${Date.now()}.wav`;

            formData.append('file', audioBlob, filename);
            formData.append('mode', mode);
            if (mode === 'Summary') {
                formData.append('summary_length', summaryLength);
            }
            formData.append('is_upload', isUpload ? 'true' : 'false');
            formData.append('session_id', currentSessionId);
            formData.append('result_order', resultOrderCounter.toString());

            try {
                const fullMode = mode === 'Summary' ? `${mode} ${summaryLength}` : mode;
                log(`üì§ Uploading final WAV to server... (Mode: ${fullMode})`);

                const response = await fetch(`${serverUrl}/process_audio`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Server request failed');
                }

                const data = await response.json();
                log(`‚úì Final job created: ${data.job_id.substring(0, 8)}... (${fullMode})`);

                await waitForJobCompletion(data.job_id, mode, summaryLength);

            } catch (error) {
                log('‚úó Error sending final audio: ' + error.message);
                alert('Error uploading final audio: ' + error.message);
            }
        }

        async function waitForJobCompletion(jobId, originalMode, summaryLength) {
            return new Promise(async (resolve, reject) => {
                const maxAttempts = 180;
                let attempts = 0;

                const checkStatus = async () => {
                    attempts++;

                    try {
                        const response = await fetch(`${serverUrl}/job_status/${jobId}`);

                        if (!response.ok) {
                            throw new Error('Failed to get job status');
                        }

                        const data = await response.json();

                        if (data.status === 'completed') {
                            log(`‚úì Final job ${jobId.substring(0, 8)}... completed!`);
                            displayResult(data, originalMode, summaryLength);
                            resolve();
                        } else if (data.status === 'error') {
                            log(`‚úó Final job ${jobId.substring(0, 8)}... failed: ${data.error}`);
                            reject(new Error('Processing failed: ' + data.error));
                        } else if (attempts >= maxAttempts) {
                            log(`‚è± Final job ${jobId.substring(0, 8)}... timed out`);
                            reject(new Error('Processing timed out'));
                        } else {
                            if (attempts % 5 === 0) {
                                log(`‚è≥ Processing final chunk... (${attempts}s)`);
                            }
                            setTimeout(checkStatus, 1000);
                        }
                    } catch (error) {
                        log('‚úó Error checking final job status: ' + error.message);
                        reject(error);
                    }
                };

                checkStatus();
            });
        }

        async function pollJobStatus(jobId, originalMode, summaryLength) {
            const maxAttempts = 180;
            let attempts = 0;
            let completed = false;

            const pollInterval = setInterval(async () => {
                if (completed) return;

                attempts++;

                try {
                    const response = await fetch(`${serverUrl}/job_status/${jobId}`);

                    if (!response.ok) {
                        throw new Error('Failed to get job status');
                    }

                    const data = await response.json();

                    if (completed) return;

                    if (data.status === 'completed') {
                        completed = true;
                        clearInterval(pollInterval);
                        log(`‚úì Job ${jobId.substring(0, 8)}... completed!`);
                        displayResult(data, originalMode, summaryLength);
                    } else if (data.status === 'error') {
                        completed = true;
                        clearInterval(pollInterval);
                        log(`‚úó Job ${jobId.substring(0, 8)}... failed: ${data.error}`);
                        alert('Processing failed: ' + data.error);
                    } else if (attempts >= maxAttempts) {
                        completed = true;
                        clearInterval(pollInterval);
                        log(`‚è± Job ${jobId.substring(0, 8)}... timed out`);
                        alert('Processing timed out. Please try again.');
                    } else if (attempts % 5 === 0) {
                        log(`‚è≥ Processing... (${attempts}s)`);
                    }
                } catch (error) {
                    if (!completed) {
                        completed = true;
                        clearInterval(pollInterval);
                        log('‚úó Error polling job status: ' + error.message);
                    }
                }
            }, 1000);
        }

        function displayResult(jobData, originalMode, summaryLength) {
            document.getElementById('resultsSection').style.display = 'block';
            const resultsContainer = document.getElementById('results');

            const resultDiv = document.createElement('div');
            resultDiv.className = 'result-item';

            const header = document.createElement('div');
            header.className = 'result-header';

            const title = document.createElement('h3');

            const resultNumber = allResults.length + 1;

            if (originalMode === 'Summary' && summaryLength) {
                title.textContent = `${resultNumber}. Summary (${summaryLength})`;
            } else if (originalMode === 'GLOBAL SUMMARY') {
                title.textContent = `${resultNumber}. Global Summary`;
            } else if (originalMode === 'Action Points') {
                title.textContent = `${resultNumber}. Action Points`;
            } else {
                title.textContent = `${resultNumber}. ${originalMode}` ;
            }

            header.appendChild(title);

            const content = document.createElement('div');
            content.className = 'result-content';

            const cleanText = jobData.result
                .replace(/\[SUMMARY[^\]]*\]\s*/g, '')
                .replace(/\[ACTION POINTS\]\s*/g, '')
                .replace(/\[GLOBAL SUMMARY\]\s*/g, '')
                .trim();

            content.innerHTML = formatTextToHTML(cleanText);

            resultDiv.appendChild(header);
            resultDiv.appendChild(content);

            resultsContainer.appendChild(resultDiv);

            allResults.push({
                mode: originalMode,
                summaryLength: summaryLength,
                result: jobData.result,
                timestamp: new Date().toISOString()
            });

            resultDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

            log('‚úÖ Result automatically saved to session');
        }

        function formatTextToHTML(text) {
            text = text
                .replace(/\*\*\*/g, '')
                .replace(/\*\*/g, '')
                .replace(/\*/g, '')
                .replace(/__|__/g, '')
                .replace(/\#\#\#/g, '')
                .replace(/\#\#/g, '')
                .replace(/\#/g, '')
                .replace(/~~(.+?)~~/g, '$1');

            let html = '';
            const lines = text.split('\n');
            let inParagraph = false;
            let inOrderedList = false;
            let inUnorderedList = false;

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i].trim();

                if (line === '') {
                    if (inParagraph) {
                        html += '</p>';
                        inParagraph = false;
                    }
                    if (inOrderedList) {
                        html += '</ol>';
                        inOrderedList = false;
                    }
                    if (inUnorderedList) {
                        html += '</ul>';
                        inUnorderedList = false;
                    }
                    continue;
                }

                const actionMatch = line.match(/^‚û§\s*(.+)/);
                if (actionMatch) {
                    if (inParagraph) {
                        html += '</p>';
                        inParagraph = false;
                    }
                    if (inOrderedList) {
                        html += '</ol>';
                        inOrderedList = false;
                    }
                    if (inUnorderedList) {
                        html += '</ul>';
                        inUnorderedList = false;
                    }
                    html += `<div class="action-item">${actionMatch[1]}</div>`;
                    continue;
                }

                const numberedMatch = line.match(/^(\d+)[\.\)]\s+(.+)/);
                if (numberedMatch) {
                    if (inParagraph) {
                        html += '</p>';
                        inParagraph = false;
                    }
                    if (inUnorderedList) {
                        html += '</ul>';
                        inUnorderedList = false;
                    }
                    if (!inOrderedList) {
                        html += '<ol>';
                        inOrderedList = true;
                    }
                    html += `<li>${numberedMatch[2]}</li>`;
                    continue;
                }

                const bulletMatch = line.match(/^[-‚Ä¢]\s+(.+)/);
                if (bulletMatch) {
                    if (inParagraph) {
                        html += '</p>';
                        inParagraph = false;
                    }
                    if (inOrderedList) {
                        html += '</ol>';
                        inOrderedList = false;
                    }
                    if (!inUnorderedList) {
                        html += '<ul>';
                        inUnorderedList = true;
                    }
                    html += `<li>${bulletMatch[1]}</li>`;
                    continue;
                }

                if (line.match(/^[A-Z\s]{4,}:?\s*$/)) {
                    if (inParagraph) {
                        html += '</p>';
                        inParagraph = false;
                    }
                    if (inOrderedList) {
                        html += '</ol>';
                        inOrderedList = false;
                    }
                    if (inUnorderedList) {
                        html += '</ul>';
                        inUnorderedList = false;
                    }
                    html += `<h4>${line.replace(/:+$/, '')}</h4>`;
                    continue;
                }

                if (inOrderedList) {
                    html += '</ol>';
                    inOrderedList = false;
                }
                if (inUnorderedList) {
                    html += '</ul>';
                    inUnorderedList = false;
                }

                if (!inParagraph) {
                    html += '<p>';
                    inParagraph = true;
                } else {
                    html += ' ';
                }
                html += line;
            }

            if (inParagraph) {
                html += '</p>';
            }
            if (inOrderedList) {
                html += '</ol>';
            }
            if (inUnorderedList) {
                html += '</ul>';
            }

            return html;
        }

        async function genGlobalSummary() {
            if (!currentSessionId) {
                alert('Please create or select a session first');
                return;
            }

            if (allResults.length === 0) {
                log('‚úó No results available for global summary');
                alert('No results available. Please process some audio first.');
                return;
            }

            // Find the button and disable it
            const globalSummaryBtn = event.target || document.querySelector('button[onclick="genGlobalSummary()"]');
            const originalText = globalSummaryBtn.textContent;
            globalSummaryBtn.disabled = true;
            globalSummaryBtn.textContent = 'Generating...';

            log('üåê Generating global summary...');

            try {
                const texts = allResults.map(r => r.result);

                const response = await fetch(`${serverUrl}/global_summary`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        texts: texts,
                        session_id: currentSessionId
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Failed to generate global summary');
                }

                const data = await response.json();

                displayResult({
                    mode: 'GLOBAL SUMMARY',
                    result: data.global_summary,
                    summary_length: ''
                }, 'GLOBAL SUMMARY', null);

                log('‚úÖ Global summary generated and saved successfully!');

                // Reload session to update result count
                await loadUserSessions();

            } catch (error) {
                log('‚úó Error generating global summary: ' + error.message);
                alert('Error generating global summary: ' + error.message);
            } finally {
                // Re-enable button after completion or error
                globalSummaryBtn.disabled = false;
                globalSummaryBtn.textContent = originalText;
            }
        }

        async function saveResults() {
            if (allResults.length === 0) {
                log('‚úó No results to save');
                alert('No results to save. Please process some audio first.');
                return;
            }

            log('üíæ Preparing results for download...');

            try {
                const meetingDate = document.getElementById('date').value || 'Not specified';
                const meetingTime = document.getElementById('time').value || 'Not specified';
                const venue = document.getElementById('venue').value || 'Not specified';
                const agenda = document.getElementById('agenda').value || 'Not specified';

                let htmlContent = `
                    <html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'>
                    <head>
                        <meta charset='utf-8'>
                        <title>Discussion Summary</title>
                        <style>
                            body {
                                font-family: Calibri, Arial, sans-serif;
                                font-size: 11pt;
                                line-height: 1.6;
                                margin: 1in;
                            }
                            h1 {
                                text-align: center;
                                color: #2E5090;
                                font-size: 24pt;
                                margin-bottom: 20pt;
                                border-bottom: 3pt solid #2E5090;
                                padding-bottom: 10pt;
                            }
                            h2 {
                                color: #2E5090;
                                font-size: 16pt;
                                margin-top: 20pt;
                                margin-bottom: 10pt;
                                border-bottom: 2pt solid #D0D0D0;
                                padding-bottom: 5pt;
                            }
                            h3 {
                                color: #4472C4;
                                font-size: 14pt;
                                margin-top: 15pt;
                                margin-bottom: 8pt;
                            }
                            h4 {
                                color: #5B9BD5;
                                font-size: 12pt;
                                margin-top: 12pt;
                                margin-bottom: 6pt;
                            }
                            p {
                                margin: 8pt 0;
                                text-align: justify;
                                line-height: 1.6;
                            }
                            ul, ol {
                                margin: 10pt 0;
                                padding-left: 30pt;
                            }
                            li {
                                margin: 6pt 0;
                            }
                            .action-item {
                                margin: 6pt 0;
                                padding-left: 20pt;
                            }
                            .action-item::before {
                                content: '‚û§ ';
                                color: #2E5090;
                                font-weight: bold;
                                margin-left: -20pt;
                                margin-right: 8pt;
                            }
                            .result-section {
                                margin-top: 20pt;
                                padding: 15pt;
                                border: 2pt solid #D0D0D0;
                                border-radius: 5pt;
                                background-color: #FAFAFA;
                                page-break-inside: avoid;
                            }
                            .footer {
                                margin-top: 30pt;
                                padding-top: 15pt;
                                border-top: 2pt solid #D0D0D0;
                                font-size: 9pt;
                                color: #666666;
                                text-align: center;
                            }
                        </style>
                    </head>
                    <body>
                        <h1>Discussion Summary</h1>

                        <h2>Meeting Information</h2>

                        <p><strong>Date:</strong> ${meetingDate} &nbsp;&nbsp;&nbsp;
                        <strong>Time:</strong> ${meetingTime} &nbsp;&nbsp;&nbsp;
                        <strong>Venue:</strong> ${venue}</p>

                        <p><strong>Agenda:</strong> ${agenda}</p>

                        <h2>Results</h2>
                `;

                allResults.forEach((result, index) => {
                    const cleanText = result.result
                        .replace(/\[SUMMARY[^\]]*\]\s*/g, '')
                        .replace(/\[ACTION POINTS\]\s*/g, '')
                        .replace(/\[GLOBAL SUMMARY\]\s*/g, '')
                        .trim();

                    const formattedContent = formatTextToHTML(cleanText);

                    let modeTitle = result.mode;
                    if (result.mode === 'Summary' && result.summaryLength) {
                        modeTitle = `Summary (${result.summaryLength})`;
                    }

                    htmlContent += `
                        <div class="result-section">
                            <h3>${index + 1}. ${modeTitle.toUpperCase()}</h3>
                            ${formattedContent}
                        </div>
                    `;
                });

                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                htmlContent += `
                        <div class="footer">
                            <p>Generated on: ${new Date().toLocaleString()}</p>
                            <p>Document: Discussion_Summary_${timestamp}.doc</p>
                            <p>Prepared by <strong>Directorate of Embedded AI Systems Team</strong></p>
                        </div>
                    </body>
                    </html>
                `;

                const blob = new Blob(['\ufeff', htmlContent], {
                    type: 'application/msword'
                });

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `Discussion_Summary_${timestamp}.doc`;
                a.click();
                URL.revokeObjectURL(url);

                log(`‚úî Results saved: Discussion_Summary_${timestamp}.doc`);
                alert('Results saved successfully as Word document!');

            } catch (error) {
                log('‚úó Error saving results: ' + error.message);
                alert('Error saving results: ' + error.message);
            }
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                if (!isPaused) {
                    const elapsed = Math.floor((Date.now() - startTime - pausedTime) / 1000);
                    const hours = Math.floor(elapsed / 3600);
                    const minutes = Math.floor((elapsed % 3600) / 60);
                    const seconds = elapsed % 60;

                    document.getElementById('timer').textContent =
                        `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function log(message) {
            const statusBox = document.getElementById('status');
            const p = document.createElement('p');
            const timestamp = new Date().toLocaleTimeString();
            p.textContent = `[${timestamp}] ${message}`;
            statusBox.appendChild(p);
            statusBox.scrollTop = statusBox.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }

        function encodeWAV(samples, inputSampleRate, outputSampleRate) {
            let resampledData;
            if (inputSampleRate !== outputSampleRate) {
                const ratio = inputSampleRate / outputSampleRate;
                const newLength = Math.round(samples.length / ratio);
                resampledData = new Float32Array(newLength);

                for (let i = 0; i < newLength; i++) {
                    const srcIndex = i * ratio;
                    const srcIndexFloor = Math.floor(srcIndex);
                    const srcIndexCeil = Math.min(srcIndexFloor + 1, samples.length - 1);
                    const t = srcIndex - srcIndexFloor;
                    resampledData[i] = samples[srcIndexFloor] * (1 - t) + samples[srcIndexCeil] * t;
                }
            } else {
                resampledData = samples;
            }

            const buffer = new ArrayBuffer(44 + resampledData.length * 2);
            const view = new DataView(buffer);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + resampledData.length * 2, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, outputSampleRate, true);
            view.setUint32(28, outputSampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, resampledData.length * 2, true);

            floatTo16BitPCM(view, 44, resampledData);

            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function floatTo16BitPCM(view, offset, input) {
            for (let i = 0; i < input.length; i++, offset += 2) {
                const s = Math.max(-1, Math.min(1, input[i]));
                view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
        }

        // ADD THESE NEW FUNCTIONS HERE
        // Close all menus when clicking outside
        
        // ============================================================================
        // VIEW MANAGEMENT (Personal / Project Toggle)
        // ============================================================================

        function showPersonalView() {
            currentView = 'personal';
            currentProjectId = null;

            // Update toggle buttons
            document.getElementById('personalBtn').classList.add('active');
            document.getElementById('projectBtn').classList.remove('active');

            // Show/hide views
            document.getElementById('personalView').style.display = 'block';
            document.getElementById('projectView').style.display = 'none';

            // Load personal sessions
            loadUserSessions();
        }

        function showProjectView() {
            currentView = 'project';

            // Update toggle buttons
            document.getElementById('personalBtn').classList.remove('active');
            document.getElementById('projectBtn').classList.add('active');

            // Show/hide views
            document.getElementById('personalView').style.display = 'none';
            document.getElementById('projectView').style.display = 'block';

            // Render projects
            renderProjects();
        }

        function renderProjects() {
            const container = document.getElementById('projectsList');
            
            container.innerHTML = PROJECTS.map(project => `
                <div class="project-item ${currentProjectId === project.project_id ? 'active' : ''}" 
                     onclick="selectProject('${project.project_id}', '${project.project_name}')">
                    <div class="project-item-name">
                        üìÅ ${project.project_name}
                        <span class="project-item-badge">SHARED</span>
                    </div>
                </div>
            `).join('');
        }

        async function selectProject(projectId, projectName) {
            try {
                currentProjectId = projectId;
                log(`üìÇ Selected project: ${projectName}`);

                // Load this project session
                await loadProjectSession(projectId, projectName);

                // Update project list to show active state
                renderProjects();

            } catch (error) {
                log('‚úó Error selecting project: ' + error.message);
            }
        }

        async function loadProjectSession(projectId, projectName) {
            try {
                // Fetch or create project session
                const response = await fetch(`/discussion_session/${projectId}`);
                const data = await response.json();

                if (data.status === 'success') {
                    const session = data.session;
                    currentSessionId = projectId;

                    // Update metadata fields
                    document.getElementById('date').value = session.meeting_date || '';
                    document.getElementById('time').value = session.meeting_time || '';
                    document.getElementById('venue').value = session.venue || '';
                    document.getElementById('agenda').value = session.agenda || '';

                    // CLEAR and reload results
                    allResults = [];
                    resultOrderCounter = 0;

                    const resultsContainer = document.getElementById('results');
                    resultsContainer.innerHTML = '';

                    if (session.results && session.results.length > 0) {
                        document.getElementById('resultsSection').style.display = 'block';
                        session.results.forEach((result, index) => {
                            displayStoredResult(result, index + 1);
                            allResults.push({
                                mode: result.mode,
                                summaryLength: result.summary_length,
                                result: result.result_text,
                                timestamp: result.created_at
                            });
                        });
                        resultOrderCounter = session.results.length;
                    } else {
                        document.getElementById('resultsSection').style.display = 'none';
                    }

                    updateSessionBanner(`Active Project: ${projectName}`);
                    log(`‚úì Loaded project: ${projectName}`);
                } else {
                    // Project session doesn't exist, create it
                    await createProjectSession(projectId, projectName);
                }

            } catch (error) {
                log('‚úó Error loading project session: ' + error.message);
                // If session doesn't exist, create it
                await createProjectSession(projectId, projectName);
            }
        }

        async function createProjectSession(projectId, projectName) {
            try {
                const response = await fetch('/create_discussion_session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({
                        session_id: projectId,
                        session_name: projectName,
                        session_type: 'project'
                    })
                });

                const data = await response.json();

                if (data.status === 'success') {
                    currentSessionId = projectId;
                    
                    // Clear UI
                    allResults = [];
                    resultOrderCounter = 0;
                    document.getElementById('results').innerHTML = '';
                    document.getElementById('resultsSection').style.display = 'none';
                    document.getElementById('date').value = '';
                    document.getElementById('time').value = '';
                    document.getElementById('venue').value = '';
                    document.getElementById('agenda').value = '';

                    updateSessionBanner(`Active Project: ${projectName}`);
                    log(`‚úì Created new project session: ${projectName}`);
                } else {
                    alert('Failed to create project session');
                }
            } catch (error) {
                log('‚úó Error creating project session: ' + error.message);
                alert('Error creating project session');
            }
        }

        // ============================================================================
        // END OF NEW FUNCTIONS
        // ============================================================================
        
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.session-options-btn')) {
                document.querySelectorAll('.session-menu').forEach(m => m.style.display = 'none');
            }
        });

        function toggleSessionMenu(sessionId, event) {
            event.stopPropagation();
            const menu = document.getElementById(`menu-${sessionId}`);

            // Close all other menus first
            document.querySelectorAll('.session-menu').forEach(m => {
                if (m.id !== `menu-${sessionId}`) {
                    m.style.display = 'none';
                }
            });

            // Toggle this menu
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
        }

        async function renameSession(sessionId, event) {
            event.stopPropagation();

            // Close menu
            document.getElementById(`menu-${sessionId}`).style.display = 'none';

            // Get current name
            const session = userSessions.find(s => s.session_id === sessionId);
            const currentName = session ? session.session_name : '';

            const newName = prompt('Enter new session name:', currentName);

            if (!newName || !newName.trim() || newName.trim() === currentName) {
                return; // Cancelled or no change
            }

            try {
                const response = await fetch('/rename_discussion_session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: sessionId,
                        new_name: newName.trim()
                    })
                });

                const data = await response.json();

                if (data.status === 'success') {
                    log('‚úì Session renamed successfully');
                    await loadUserSessions();

                    // Update banner if this is the active session
                    if (currentSessionId === sessionId) {
                        updateSessionBanner(`Active Session: ${newName.trim()}`);
                    }
                } else {
                    alert('Failed to rename session');
                }
            } catch (error) {
                log('‚úó Error renaming session: ' + error.message);
                alert('Error renaming session');
            }
        }

        async function deleteSession(sessionId, event) {
            event.stopPropagation();

            // Close menu
            document.getElementById(`menu-${sessionId}`).style.display = 'none';

            const session = userSessions.find(s => s.session_id === sessionId);
            const sessionName = session ? session.session_name : 'this session';

            if (!confirm(`Are you sure you want to delete "${sessionName}"?\n\nAll results will be permanently deleted.`)) {
                return;
            }

            try {
                const response = await fetch('/delete_discussion_session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId })
                });

                const data = await response.json();

                if (data.status === 'success') {
                    log('‚úì Session deleted successfully');

                    // If deleted session was active, clear the UI
                    if (currentSessionId === sessionId) {
                        currentSessionId = null;
                        allResults = [];
                        resultOrderCounter = 0;

                        document.getElementById('results').innerHTML = '';
                        document.getElementById('resultsSection').style.display = 'none';
                        document.getElementById('date').value = '';
                        document.getElementById('time').value = '';
                        document.getElementById('venue').value = '';
                        document.getElementById('agenda').value = '';
                    }

                    // Reload sessions list
                    await loadUserSessions();

                } else {
                    alert('Failed to delete session');
                }
            } catch (error) {
                log('‚úó Error deleting session: ' + error.message);
                alert('Error deleting session');
            }
        }
        // END OF NEW FUNCTIONS

    </script>
</body>
</html>


from fastapi import FastAPI, File, UploadFile, Form, HTTPException, Request, Response, Depends, Cookie
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import HTMLResponse, RedirectResponse, JSONResponse, FileResponse, Response
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel
from typing import List, Optional
import uvicorn
import httpx
import logging
from pathlib import Path
from datetime import datetime, timedelta
import os
import secrets
import sqlite3
from threading import Lock
import re
from urllib.parse import quote

# LDAP imports


logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Configuration
GPU_SERVER_URL = "http://127.0.0.1:8001"  # GPU processing server
LOGS_DIR = Path("./logs")
LOGS_DIR.mkdir(exist_ok=True)
DB_FILE = Path("./auth_sessions.db")
SESSION_TIMEOUT = 7200  # 2 hours in seconds

# Database lock
db_lock = Lock()

app = FastAPI(title="DEAIS MOM Server", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
app.mount("/mom_icons", StaticFiles(directory="mom_icons"), name="mom_icons")


# app.mount("/public", StaticFiles(directory="public"), name="public")
# app.mount("/static", StaticFiles(directory="static"), name="static")


class GlobalSummaryRequest(BaseModel):
    texts: List[str]
    session_id: Optional[str] = None


class SessionMetadataRequest(BaseModel):
    session_id: str
    meeting_date: Optional[str] = None
    meeting_time: Optional[str] = None
    venue: Optional[str] = None
    agenda: Optional[str] = None


# ============================================================================
# DATABASE INITIALIZATION
# ============================================================================

def initialize_auth_database():
    """Initialize SQLite database for session management"""
    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # Sessions table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS sessions (
                session_token TEXT PRIMARY KEY,
                username TEXT NOT NULL,
                display_name TEXT NOT NULL,
                created_at DATETIME NOT NULL,
                last_activity DATETIME NOT NULL,
                ip_address TEXT
            )
        """)

        # Local users table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS local_users (
                username TEXT PRIMARY KEY,
                password TEXT NOT NULL,
                display_name TEXT NOT NULL,
                created_at DATETIME NOT NULL
            )
        """)

        conn.commit()

        # Add default users if table is empty
        cursor.execute("SELECT COUNT(*) FROM local_users")
        if cursor.fetchone()[0] == 0:
            default_users = [
                ("admin", "admin123", "Administrator"),
                ("john", "pass123", "John Doe"),
                ("jane", "pass456", "Jane Smith"),
                ("dlpda", "dl@209", "DLPDA"),

            ]

            for username, password, display_name in default_users:
                cursor.execute("""
                    INSERT INTO local_users (username, password, display_name, created_at)
                    VALUES (?, ?, ?, ?)
                """, (username, password, display_name, datetime.now().isoformat()))

            conn.commit()
            logger.info(f"‚úì Created {len(default_users)} default users")

        conn.close()


def cleanup_expired_sessions():
    """Remove expired sessions from database"""
    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        expiry_time = (datetime.now() - timedelta(seconds=SESSION_TIMEOUT)).isoformat()
        cursor.execute("DELETE FROM sessions WHERE last_activity < ?", (expiry_time,))
        conn.commit()
        conn.close()


def create_session(username: str, display_name: str, ip_address: str) -> str:
    """Create a new session and return session token"""
    session_token = secrets.token_urlsafe(32)
    now = datetime.now().isoformat()

    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO sessions (session_token, username, display_name, created_at, last_activity, ip_address)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (session_token, username, display_name, now, now, ip_address))
        conn.commit()
        conn.close()

    return session_token


def validate_session(session_token: str) -> Optional[dict]:
    """Validate session token and return user data if valid"""
    if not session_token:
        return None

    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("""
            SELECT username, display_name, last_activity
            FROM sessions
            WHERE session_token = ?
        """, (session_token,))
        result = cursor.fetchone()

        if result:
            username, display_name, last_activity = result
            last_activity_dt = datetime.fromisoformat(last_activity)

            # Check if session expired
            if datetime.now() - last_activity_dt > timedelta(seconds=SESSION_TIMEOUT):
                cursor.execute("DELETE FROM sessions WHERE session_token = ?", (session_token,))
                conn.commit()
                conn.close()
                return None

            # Update last activity
            cursor.execute("""
                UPDATE sessions
                SET last_activity = ?
                WHERE session_token = ?
            """, (datetime.now().isoformat(), session_token))
            conn.commit()
            conn.close()

            return {
                "username": username,
                "display_name": display_name
            }

        conn.close()
        return None


def delete_session(session_token: str):
    """Delete a session (logout)"""
    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("DELETE FROM sessions WHERE session_token = ?", (session_token,))
        conn.commit()
        conn.close()


# ============================================================================
# LDAP AUTHENTICATION
# ============================================================================

def authenticate_local_user(username: str, password: str, client_ip: str):
    """
    Simple authentication against local database
    """
    try:
        with db_lock:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()

            cursor.execute("""
                SELECT password, display_name
                FROM local_users
                WHERE username = ?
            """, (username,))

            result = cursor.fetchone()
            conn.close()

            if result:
                stored_password, display_name = result
                if password == stored_password:
                    logger.info(f"‚úì Login Success: {username} ({display_name}) from {client_ip}")
                    return True, display_name
                else:
                    logger.warning(f"‚úó Login Failed: {username} - Wrong password from {client_ip}")
                    return False, "Invalid password"
            else:
                logger.warning(f"‚úó Login Failed: {username} - User not found from {client_ip}")
                return False, "User not found"

    except Exception as e:
        logger.error(f"‚úó Auth Error: {username} - {str(e)}")
        return False, f"Authentication error: {str(e)}"


# ============================================================================
# SESSION DEPENDENCY
# ============================================================================

async def get_current_user(session_token: Optional[str] = Cookie(None)):
    """Dependency to get current logged-in user"""
    logger.info(f"session token received:{session_token}")
    if not session_token:
        return None

    user = validate_session(session_token)
    logger.info(f"Validated user: {user}")
    return user


async def require_auth(user: Optional[dict] = Depends(get_current_user)):
    """Dependency to require authentication"""
    if not user:
        raise HTTPException(status_code=401, detail="Not authenticated")
    return user


# ============================================================================
# LOGGING FUNCTIONS
# ============================================================================

def get_log_filename():
    """Get today's log filename"""
    today = datetime.now().strftime("%Y-%m-%d")
    return LOGS_DIR / f"{today}.txt"


def write_log(log_message: str):
    """Write log message to today's log file"""
    try:
        log_file = get_log_filename()
        with open(log_file, "a", encoding="utf-8") as f:
            f.write(log_message + "\n")
    except Exception as e:
        logger.error(f"Error writing to log file: {str(e)}")


def get_client_ip(request: Request) -> str:
    """Extract client IP address from request"""
    forwarded = request.headers.get("X-Forwarded-For")
    if forwarded:
        return forwarded.split(",")[0].strip()

    real_ip = request.headers.get("X-Real-IP")
    if real_ip:
        return real_ip

    if request.client:
        return request.client.host

    return "Unknown"


def log_page_access(ip: str, page: str):
    """Log page access"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_message = f"IP: {ip} | Timestamp: {timestamp} | Page: {page}"
    write_log(log_message)


def log_dictation(ip: str, duration_seconds: float, result_text: str):
    """Log dictation session"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    minutes = int(duration_seconds // 60)
    seconds = int(duration_seconds % 60)
    duration_str = f"{minutes}m {seconds}s" if minutes > 0 else f"{seconds}s"

    log_message = f"IP: {ip} | Timestamp: {timestamp} | Page: Dictation | Duration: {duration_str}"
    write_log(log_message)


def log_discussion_summary_record(ip: str, mode: str, summary_length: str, filename: str, status: str,
                                  result_text: str = ""):
    """Log Discussion Summary with RECORD"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    if mode == "Summary":
        mode_text = f"Summary ({summary_length})"
    else:
        mode_text = mode

    log_message = f"IP: {ip} | Timestamp: {timestamp} | Page: Discussion Summary [RECORD] | Mode: {mode_text} | File: {filename} | Status: {status}"
    write_log(log_message)


def log_discussion_summary_upload(ip: str, mode: str, summary_length: str, filename: str, status: str,
                                  result_text: str = ""):
    """Log Discussion Summary with UPLOAD"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    if mode == "Summary":
        mode_text = f"Summary ({summary_length})"
    else:
        mode_text = mode

    log_message = f"IP: {ip} | Timestamp: {timestamp} | Page: Discussion Summary [UPLOAD] | Mode: {mode_text} | File: {filename} | Status: {status}"
    write_log(log_message)


# Store job metadata temporarily to link with results
job_metadata = {}


# ============================================================================
# AUTHENTICATION ROUTES
# ============================================================================
@app.get("/favicon.ico")
async def favicon():
    return FileResponse("static/logo.png", media_type="image/png")


@app.get("/login", response_class=HTMLResponse)
async def login_page(request: Request):
    """Serve the login page"""
    client_ip = get_client_ip(request)
    log_page_access(client_ip, "Login Page")

    html_content = """
    <!DOCTYPE html>
    <html lang="en">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <style>
        body {
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #fff;
        }
        .login-container {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(14px);
            -webkit-backdrop-filter: blur(14px);
            border-radius: 25px;
            padding: 50px 60px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }
        h1 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 2em;
        }
        p.subtitle {
            color: #e0e0e0;
            font-size: 1.1em;
            margin-bottom: 35px;
        }
        .form-group {
            margin-bottom: 25px;
            text-align: left;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #fff;
        }
        input[type="text"],
        input[type="password"] {
            width: 100%;
            padding: 12px 15px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            background: rgba(255, 255, 255, 0.9);
            box-sizing: border-box;
        }
        input:focus {
            outline: 2px solid #ffeb3b;
        }
        button {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: 600;
            background: linear-gradient(135deg, #ffeb3b 0%, #ffc107 100%);
            color: #333;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }
        .error {
            background: rgba(255, 82, 82, 0.9);
            color: white;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }
        .success {
            background: rgba(76, 175, 80, 0.9);
            color: white;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }
        footer {
            margin-top: 30px;
            color: #eaeaea;
            font-size: 0.85em;
        }
    </style>
    </head>
    <body>
        <div class="login-container">
            <h1></h1>
            <p class="subtitle">You Can Login With RCNET Username & Password here</p>

            <div id="error-message" class="error"></div>
            <div id="success-message" class="success"></div>

            <form id="login-form">
                <div class="form-group">
                    <label for="username">PIS Number / Username</label>
                    <input type="text" id="username" name="username" required autofocus>
                </div>

                <div class="form-group">
                    <label for="password">Password</label>
                    <input type="password" id="password" name="password" required>
                </div>

                <button type="submit" id="login-btn">Login</button>
            </form>

            <footer>
                <p></p>
                <p></p>
            </footer>
        </div>

        <script>
            const form = document.getElementById('login-form');
            const errorDiv = document.getElementById('error-message');
            const successDiv = document.getElementById('success-message');
            const loginBtn = document.getElementById('login-btn');

            form.addEventListener('submit', async (e) => {
                e.preventDefault();

                const username = document.getElementById('username').value;
                const password = document.getElementById('password').value;

                // Hide messages
                errorDiv.style.display = 'none';
                successDiv.style.display = 'none';

                // Disable button
                loginBtn.disabled = true;
                loginBtn.textContent = 'Authenticating...';

                try {
                    const formData = new FormData();
                    formData.append('username', username);
                    formData.append('password', password);

                    const response = await fetch('/authenticate', {
                        method: 'POST',
                        body: formData,
                        credentials: "include"

                    });
                    console.log(response)
                    const data = await response.json();

                    if (response.ok) {
                        successDiv.textContent = 'Login successful! ...';
                        successDiv.style.display = 'block';
                        setTimeout(() => {
                            window.location.href = '/';
                        }, 1000);
                    } else {

                        errorDiv.textContent = data.error || 'Authentication failed';
                        errorDiv.style.display = 'block';
                        loginBtn.disabled = false;
                        loginBtn.textContent = 'Login';
                    }
                } catch (error) {
                    errorDiv.textContent = 'username or password incorrect';
                    errorDiv.style.display = 'block';
                    loginBtn.disabled = false;
                    loginBtn.textContent = 'Login';
                }
            });
        </script>
    </body>
    </html>
    """
    return HTMLResponse(content=html_content)


@app.post("/authenticate")
async def authenticate(
        request: Request,
        username: str = Form(...),
        password: str = Form(...)
):
    """Authenticate user via LDAP and create session"""
    client_ip = get_client_ip(request)

    # Clean expired sessions
    cleanup_expired_sessions()

    # Authenticate via LDAP
    success, display_name = authenticate_local_user(username, password, client_ip)

    if success:
        # Create session
        session_token = create_session(username, display_name, client_ip)

        # Log successful login
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_message = f"IP: {client_ip} | Timestamp: {timestamp} | Page: AD Login Success | User: {username} ({display_name})"
        write_log(log_message)

        # Create redirect response and set cookie
        response = JSONResponse(content={
            "success": True,
            "message": "login Successful",
            "redirect": "/"
        })
        response.set_cookie(
            key="session_token",
            value=session_token,
            httponly=True,
            secure=False,  # Set to True in production
            samesite="lax",

            path="/"
        )

        return response
    else:
        # Log failed login
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_message = f"IP: {client_ip} | Timestamp: {timestamp} | Page: AD Login Failed | User: {username} | Reason: {display_name}"
        write_log(log_message)

        # Redirect back to login with error message
        from urllib.parse import quote
        error_msg = quote(display_name)
        return RedirectResponse(
            url=f"/login?error={error_msg}",
            status_code=303
        )


@app.get("/logout")
async def logout(
        response: Response,
        request: Request,
        session_token: Optional[str] = Cookie(None)
):
    """Logout user and clear session"""
    client_ip = get_client_ip(request)

    if session_token:
        user = validate_session(session_token)
        if user:
            # Log logout
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            log_message = f"IP: {client_ip} | Timestamp: {timestamp} | Page: Logout | User: {user['username']}"
            write_log(log_message)

        # Delete session
        delete_session(session_token)

    # Clear cookie
    response.delete_cookie(key="session_token")

    return RedirectResponse(url="/login", status_code=303)


# ============================================================================
# PROTECTED HTML ROUTES
# ============================================================================

@app.get("/", response_class=HTMLResponse)
async def serve_index(request: Request, user: dict = Depends(require_auth)):
    """Serve the index.html - PROTECTED"""
    try:
        client_ip = get_client_ip(request)
        log_page_access(client_ip, f"Index (Home) - User: {user['username']}")

        with open("index.html", "r", encoding="utf-8") as f:
            html_content = f.read()

        # Inject user info and logout button
        user_info_html = f"""
        <div style="position: fixed; top: 20px; right: 20px; background: rgba(255,255,255,0.9);
                    padding: 10px 20px; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
                    z-index: 1000;">
            <span style="color: #333; font-weight: 600;">Welcome, {user['display_name']}</span>
            <a href="/logout" style="margin-left: 15px; color: #667eea; text-decoration: none;
                                     font-weight: 600;">Logout</a>
        </div>
        """
        html_content = html_content.replace("</body>", f"{user_info_html}</body>")

        return HTMLResponse(content=html_content)
    except FileNotFoundError:
        return HTMLResponse(
            content="<h1>Error: index.html not found</h1>",
            status_code=404
        )


@app.get("/Dictation.html", response_class=HTMLResponse)
async def serve_audio_assistant(request: Request, user: dict = Depends(require_auth)):
    """Serve the Dictation page - PROTECTED"""
    try:
        client_ip = get_client_ip(request)
        log_page_access(client_ip, f"Dictation - User: {user['username']}")

        with open("Dictation.html", "r", encoding="utf-8") as f:
            html_content = f.read()

        # Inject user info
        user_info_html = f"""
        <div style="position: fixed; top: 20px; right: 20px; background: rgba(255,255,255,0.9);
                    padding: 10px 20px; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
                    z-index: 1000;">
            <span style="color: #333; font-weight: 600;">{user['display_name']}</span>
            <a href="/logout" style="margin-left: 15px; color: #667eea; text-decoration: none;
                                     font-weight: 600;">Logout</a>
        </div>
        """
        html_content = html_content.replace("</body>", f"{user_info_html}</body>")

        return HTMLResponse(content=html_content)
    except FileNotFoundError:
        return HTMLResponse(
            content="<h1>Error: Dictation.html not found</h1>",
            status_code=404
        )


@app.get("/U_S_dis.html", response_class=HTMLResponse)
async def serve_meeting_minutes(request: Request, user: dict = Depends(require_auth)):
    """Serve the Discussion Summary page - PROTECTED"""
    try:
        client_ip = get_client_ip(request)
        log_page_access(client_ip, f"Discussion Summary - User: {user['username']}")

        with open("U_S_dis.html", "r", encoding="utf-8") as f:
            html_content = f.read()

        # Inject user info
        user_info_html = f"""
        <div style="position: fixed; top: 20px; right: 20px; background: rgba(255,255,255,0.9);
                    padding: 10px 20px; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
                    z-index: 1000;">
            <span style="color: #333; font-weight: 600;">{user['display_name']}</span>
            <a href="/logout" style="margin-left: 15px; color: #667eea; text-decoration: none;
                                     font-weight: 600;">Logout</a>
        </div>
        """
        html_content = html_content.replace("</body>", f"{user_info_html}</body>")

        return HTMLResponse(content=html_content)
    except FileNotFoundError:
        return HTMLResponse(
            content="<h1>Error: Discussion_Summary.html not found</h1>",
            status_code=404
        )


@app.get("/health")
async def health_check(request: Request):
    """Health check endpoint - PUBLIC"""
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            response = await client.get(f"{GPU_SERVER_URL}/health")
            gpu_status = response.json()

            return {
                "web_server": "healthy",
                "gpu_server": gpu_status,
                "auth_system": "active"
            }
    except Exception as e:
        return {
            "web_server": "healthy",
            "gpu_server": f"unreachable: {str(e)}",
            "auth_system": "active"
        }


# ============================================================================
# API ROUTES (PROTECTED) - WITH SESSION SUPPORT
# ============================================================================

@app.post("/create_discussion_session")
async def create_discussion_session(
        request: Request,
        user: dict = Depends(require_auth),
        session_name: str = Form(None),
        session_id: str = Form(None),
        session_type: str = Form('personal')
):
    """Create a new discussion session"""
    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(
                f"{GPU_SERVER_URL}/create_session",
                data={
                    "username": user['username'],
                    "session_name": session_name,
                    "session_id": session_id,
                    "session_type": session_type
                }
            )

            if response.status_code != 200:
                raise HTTPException(status_code=response.status_code, detail=response.text)

            return response.json()
    except httpx.RequestError as e:
        logger.error(f"Error creating session: {str(e)}")
        raise HTTPException(status_code=503, detail=f"GPU server unreachable: {str(e)}")


@app.post("/update_session_metadata")
async def update_session_metadata_endpoint(
        request: Request,
        user: dict = Depends(require_auth),
        metadata: SessionMetadataRequest = None
):
    """Update session metadata"""
    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(
                f"{GPU_SERVER_URL}/update_session_metadata",
                json=metadata.dict()
            )

            if response.status_code != 200:
                raise HTTPException(status_code=response.status_code, detail=response.text)

            return response.json()
    except httpx.RequestError as e:
        logger.error(f"Error updating metadata: {str(e)}")
        raise HTTPException(status_code=503, detail=f"GPU server unreachable: {str(e)}")


@app.get("/user_discussion_sessions")
async def get_user_discussion_sessions(
        request: Request,
        user: dict = Depends(require_auth)
):
    """Get all discussion sessions for current user"""
    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.get(
                f"{GPU_SERVER_URL}/user_sessions/{user['username']}"
            )

            if response.status_code != 200:
                raise HTTPException(status_code=response.status_code, detail=response.text)

            return response.json()
    except httpx.RequestError as e:
        logger.error(f"Error fetching sessions: {str(e)}")
        raise HTTPException(status_code=503, detail=f"GPU server unreachable: {str(e)}")


@app.get("/discussion_session/{session_id}")
async def get_discussion_session(
        request: Request,
        session_id: str,
        user: dict = Depends(require_auth)
):
    """Get full session details"""
    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.get(
                f"{GPU_SERVER_URL}/session/{session_id}"
            )

            if response.status_code != 200:
                raise HTTPException(status_code=response.status_code, detail=response.text)

            return response.json()
    except httpx.RequestError as e:
        logger.error(f"Error fetching session: {str(e)}")
        raise HTTPException(status_code=503, detail=f"GPU server unreachable: {str(e)}")


@app.post("/rename_discussion_session")
async def rename_discussion_session(
        request: Request,
        user: dict = Depends(require_auth)
):
    """Forward rename request to GPU server"""
    try:
        body = await request.json()
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(
                f"{GPU_SERVER_URL}/rename_session",
                json=body
            )
            return response.json()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/delete_discussion_session")
async def delete_discussion_session(
        request: Request,
        user: dict = Depends(require_auth)
):
    """Forward delete request to GPU server"""
    try:
        body = await request.json()
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(
                f"{GPU_SERVER_URL}/delete_session",
                json=body
            )
            return response.json()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/project_session/{project_id}")
async def get_project_session_proxy(
        request: Request,
        project_id: str,
        user: dict = Depends(require_auth)
):
    """Forward get project session request to GPU server - PROTECTED"""
    try:
        client_ip = get_client_ip(request)
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.get(
                f"{GPU_SERVER_URL}/project_session/{project_id}"
            )
            return response.json()
    except httpx.RequestError as e:
        logger.error(f"Error fetching project session: {str(e)}")
        raise HTTPException(status_code=503, detail=f"GPU server unreachable: {str(e)}")
    except Exception as e:
        logger.error(f"Error in project session proxy: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/process_audio")
async def process_audio(
        request: Request,
        user: dict = Depends(require_auth),
        file: UploadFile = File(...),
        mode: str = Form(...),
        summary_length: str = Form(default="Medium"),
        is_upload: bool = Form(default=False),
        session_id: str = Form(...),
        result_order: int = Form(...)
):
    """Forward audio processing to GPU server - PROTECTED"""
    client_ip = get_client_ip(request)

    try:
        # Read file content
        file_content = await file.read()

        # Prepare multipart form data
        files = {"file": (file.filename, file_content, file.content_type)}
        data = {
            "mode": mode,
            "summary_length": summary_length,
            "session_id": session_id,
            "result_order": result_order
        }

        # Forward to GPU server
        async with httpx.AsyncClient(timeout=300.0) as client:
            response = await client.post(
                f"{GPU_SERVER_URL}/process_audio",
                files=files,
                data=data
            )

            if response.status_code != 200:
                raise HTTPException(status_code=response.status_code, detail=response.text)

            result = response.json()
            job_id = result.get("job_id", "unknown")

            # Store metadata for this job
            job_metadata[job_id] = {
                "ip": client_ip,
                "mode": mode,
                "summary_length": summary_length,
                "filename": file.filename,
                "is_upload": is_upload,
                "username": user['username']
            }

            return result

    except httpx.RequestError as e:
        logger.error(f"Error forwarding to GPU server: {str(e)}")

        # Log failure
        if is_upload:
            log_discussion_summary_upload(client_ip, mode, summary_length, file.filename, "FAILED", "")
        else:
            log_discussion_summary_record(client_ip, mode, summary_length, file.filename, "FAILED", "")

        raise HTTPException(status_code=503, detail=f"GPU server unreachable: {str(e)}")
    except Exception as e:
        logger.error(f"Error processing request: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/job_status/{job_id}")
async def get_job_status(request: Request, job_id: str, user: dict = Depends(require_auth)):
    """Check job status and log results - PROTECTED"""
    try:
        async with httpx.AsyncClient(timeout=300.0) as client:
            response = await client.get(f"{GPU_SERVER_URL}/job_status/{job_id}")

            if response.status_code == 404:
                raise HTTPException(status_code=404, detail="Job not found")

            result = response.json()

            # Log completed jobs
            if result.get("status") == "completed" and job_id in job_metadata:
                metadata = job_metadata[job_id]
                result_text = result.get("result", "")

                if metadata["is_upload"]:
                    log_discussion_summary_upload(
                        metadata["ip"],
                        metadata["mode"],
                        metadata["summary_length"],
                        metadata["filename"],
                        "SUCCESS",
                        result_text
                    )
                else:
                    log_discussion_summary_record(
                        metadata["ip"],
                        metadata["mode"],
                        metadata["summary_length"],
                        metadata["filename"],
                        "SUCCESS",
                        result_text
                    )

                # Clean up metadata
                del job_metadata[job_id]

            # Log failed jobs
            elif result.get("status") == "error" and job_id in job_metadata:
                metadata = job_metadata[job_id]

                if metadata["is_upload"]:
                    log_discussion_summary_upload(
                        metadata["ip"],
                        metadata["mode"],
                        metadata["summary_length"],
                        metadata["filename"],
                        "FAILED",
                        ""
                    )
                else:
                    log_discussion_summary_record(
                        metadata["ip"],
                        metadata["mode"],
                        metadata["summary_length"],
                        metadata["filename"],
                        "FAILED",
                        ""
                    )

                # Clean up metadata
                del job_metadata[job_id]

            return result

    except httpx.RequestError as e:
        logger.error(f"Error checking job status: {str(e)}")
        raise HTTPException(status_code=503, detail=f"GPU server unreachable: {str(e)}")


@app.post("/log_dictation")
async def log_dictation_endpoint(
        request: Request,
        user: dict = Depends(require_auth),
        duration: float = Form(...),
        result: str = Form(...)
):
    """Endpoint for frontend to log dictation sessions - PROTECTED"""
    client_ip = get_client_ip(request)
    log_dictation(client_ip, duration, result)
    return {"status": "logged"}


@app.post("/global_summary")
async def generate_global_summary(
        request: Request,
        summary_request: GlobalSummaryRequest,
        user: dict = Depends(require_auth)
):
    """Forward global summary request to GPU server - PROTECTED"""
    try:
        async with httpx.AsyncClient(timeout=300.0) as client:
            response = await client.post(
                f"{GPU_SERVER_URL}/global_summary",
                json={"texts": summary_request.texts, "session_id": summary_request.session_id}
            )

            if response.status_code != 200:
                raise HTTPException(status_code=response.status_code, detail=response.text)

            return response.json()

    except httpx.RequestError as e:
        logger.error(f"Error generating global summary: {str(e)}")
        raise HTTPException(status_code=503, detail=f"GPU server unreachable: {str(e)}")


@app.post("/create_query_session")
async def create_query_session_proxy(
        request: Request,
        user: dict = Depends(require_auth)
):
    """Forward create query session request"""
    try:
        body = await request.json()
        body['username'] = user['username']  # Add username from auth

        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(
                f"{GPU_SERVER_URL}/create_query_session",
                json=body
            )
            return response.json()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/update_query_session_selections")
async def update_query_session_selections_proxy(
        request: Request,
        user: dict = Depends(require_auth)
):
    """Forward update selections request"""
    try:
        body = await request.json()
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(
                f"{GPU_SERVER_URL}/update_query_session_selections",
                json=body
            )
            return response.json()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/upload_document")
async def upload_document_proxy(
        request: Request,
        user: dict = Depends(require_auth),
        query_session_id: str = Form(...),
        file: UploadFile = File(...)
):
    """Forward document upload"""
    try:
        file_content = await file.read()
        files = {"file": (file.filename, file_content, file.content_type)}
        data = {"query_session_id": query_session_id}

        async with httpx.AsyncClient(timeout=60.0) as client:
            response = await client.post(
                f"{GPU_SERVER_URL}/upload_document",
                files=files,
                data=data
            )
            return response.json()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/query_session/{query_session_id}")
async def get_query_session_proxy(
        request: Request,
        query_session_id: str,
        user: dict = Depends(require_auth)
):
    """Forward get query session request"""
    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.get(
                f"{GPU_SERVER_URL}/query_session/{query_session_id}"
            )
            return response.json()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/user_query_sessions")
async def get_user_query_sessions_proxy(
        request: Request,
        user: dict = Depends(require_auth)
):
    """Get all query sessions for current user"""
    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.get(
                f"{GPU_SERVER_URL}/user_query_sessions/{user['username']}"
            )
            return response.json()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/ask_question")
async def ask_question_proxy(
        request: Request,
        user: dict = Depends(require_auth)
):
    """Forward question to GPU server"""
    try:
        body = await request.json()
        async with httpx.AsyncClient(timeout=900.0) as client:
            response = await client.post(
                f"{GPU_SERVER_URL}/ask_question",
                json=body
            )
            return response.json()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/delete_query_session")
async def delete_query_session_proxy(
        request: Request,
        user: dict = Depends(require_auth)
):
    """Forward delete query session request"""
    try:
        body = await request.json()
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(
                f"{GPU_SERVER_URL}/delete_query_session",
                json=body
            )
            return response.json()
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/Query_Answering.html", response_class=HTMLResponse)
async def serve_query_answering(request: Request, user: dict = Depends(require_auth)):
    """Serve the Query Answering page - PROTECTED"""
    try:
        client_ip = get_client_ip(request)
        log_page_access(client_ip, f"Query Answering - User: {user['username']}")

        with open("Query_Answering.html", "r", encoding="utf-8") as f:
            html_content = f.read()

        # Inject user info
        user_info_html = f"""
        <div style="position: fixed; top: 20px; right: 20px; background: rgba(255,255,255,0.9);
                    padding: 10px 20px; border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
                    z-index: 1000;">
            <span style="color: #333; font-weight: 600;">{user['display_name']}</span>
            <a href="/logout" style="margin-left: 15px; color: #667eea; text-decoration: none;
                                     font-weight: 600;">Logout</a>
        </div>
        """
        html_content = html_content.replace("</body>", f"{user_info_html}</body>")

        return HTMLResponse(content=html_content)
    except FileNotFoundError:
        return HTMLResponse(
            content="<h1>Error: Query_Answering.html not found</h1>",
            status_code=404
        )


# ============================================================================
# EXCEPTION HANDLERS
# ============================================================================

@app.exception_handler(401)
async def unauthorized_handler(request: Request, exc: HTTPException):
    """Redirect unauthorized requests to login page"""
    if request.url.path.startswith("/authenticate") or request.url.path.startswith("/login"):
        return JSONResponse(
            status_code=401,
            content={"error": "Unauthorized"}
        )
    print("user unauthorised access", flush=True)
    return RedirectResponse(url="/login", status_code=303)


# ============================================================================
# SERVER STARTUP
# ============================================================================

if __name__ == "__main__":
    port = 8000

    # Initialize authentication database
    initialize_auth_database()
    cleanup_expired_sessions()

    # Log server startup
    startup_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    startup_log = f"========== SERVER STARTUP | Timestamp: {startup_time} | Port: {port} | AUTH ENABLED =========="
    write_log(startup_log)

    uvicorn.run(
        app,
        host="127.0.0.1",
        port=port,

    )


from fastapi import FastAPI, File, UploadFile, BackgroundTasks, Form, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional, Dict
from contextlib import asynccontextmanager
import torch
import uvicorn
import uuid
import shutil
from datetime import datetime
from pathlib import Path
import logging
import os
import sqlite3
from threading import Lock
import json
from sentence_transformers import SentenceTransformer
import numpy as np
import PyPDF2
import docx

from transformers.models.voxtral.modeling_voxtral import VoxtralForConditionalGeneration
from transformers import AutoProcessor

import sys
import numpy as np
from scipy.io import wavfile
from query_answering_logger import QueryLogger, timed

import time
import logging
from datetime import datetime

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Configuration
RECORDINGS_DIR = Path("./server_recordings")
RECORDINGS_DIR.mkdir(exist_ok=True)
DB_FILE = Path("./sessions.db")

model = None
processor = None
device = "cuda" if torch.cuda.is_available() else "cpu"
jobs = {}
all_results = []

embedding_model = None

# Initialize logger as a global variable (after other globals)
query_logger = QueryLogger(
    logs_dir="./query_logs",
    chunks_logs_dir="./chunk_retrieval_logs",
    enable_chunk_logging=True,
    enable_terminal_output=True
)

# Database lock
db_lock = Lock()


def initialize_sessions_database():
    """Initialize SQLite database for session management"""
    conn = sqlite3.connect(DB_FILE)
    cursor = conn.cursor()

    # Sessions table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS sessions (
            session_id TEXT PRIMARY KEY,
            username TEXT NOT NULL,
            session_name TEXT,
            meeting_date TEXT,
            meeting_time TEXT,
            venue TEXT,
            agenda TEXT,
            created_at DATETIME NOT NULL,
            updated_at DATETIME NOT NULL
        )
    """)

    # Results table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS session_results (
            result_id TEXT PRIMARY KEY,
            session_id TEXT NOT NULL,
            mode TEXT NOT NULL,
            summary_length TEXT,
            result_text TEXT NOT NULL,
            result_order INTEGER NOT NULL,
            created_at DATETIME NOT NULL,
            FOREIGN KEY (session_id) REFERENCES sessions(session_id)
        )
    """)

    # Query sessions table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS query_sessions (
            query_session_id TEXT PRIMARY KEY,
            username TEXT NOT NULL,
            session_name TEXT,
            selected_sessions TEXT,
            uploaded_documents TEXT,
            created_at DATETIME NOT NULL,
            updated_at DATETIME NOT NULL
        )
    """)

    # Q&A history table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS qa_history (
            qa_id TEXT PRIMARY KEY,
            query_session_id TEXT NOT NULL,
            question TEXT NOT NULL,
            answer TEXT NOT NULL,
            sources TEXT,
            created_at DATETIME NOT NULL,
            FOREIGN KEY (query_session_id) REFERENCES query_sessions(query_session_id)
        )
    """)

    # Uploaded documents table
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS uploaded_documents (
            document_id TEXT PRIMARY KEY,
            query_session_id TEXT NOT NULL,
            filename TEXT NOT NULL,
            content TEXT NOT NULL,
            created_at DATETIME NOT NULL,
            FOREIGN KEY (query_session_id) REFERENCES query_sessions(query_session_id)
        )
    """)

    # Check and add new columns for project support
    cursor.execute("PRAGMA table_info(sessions)")
    columns = [col[1] for col in cursor.fetchall()]

    if 'session_type' not in columns:
        cursor.execute("ALTER TABLE sessions ADD COLUMN session_type TEXT DEFAULT 'personal'")
        logger.info("‚úì Added session_type column")

    if 'project_id' not in columns:
        cursor.execute("ALTER TABLE sessions ADD COLUMN project_id TEXT")
        logger.info("‚úì Added project_id column")

    conn.commit()
    conn.close()


def initialize_project_sessions():
    """Create the 4 hardcoded project sessions if they don't exist"""
    projects = [
        {'id': 'project_1', 'name': 'Project 1'},
        {'id': 'project_2', 'name': 'Project 2'},
        {'id': 'project_3', 'name': 'Project 3'},
        {'id': 'project_4', 'name': 'Project 4'}
    ]

    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        for project in projects:
            # Check if project session exists
            cursor.execute("SELECT session_id FROM sessions WHERE session_id = ?", (project['id'],))
            if not cursor.fetchone():
                # Create project session
                now = datetime.now().isoformat()
                cursor.execute("""
                    INSERT INTO sessions (session_id, username, session_name, session_type, created_at, updated_at)
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (project['id'], 'system', project['name'], 'project', now, now))
                logger.info(f"‚úì Created project session: {project['name']}")

        conn.commit()
        conn.close()


def create_session(username: str, session_name: str = None, session_id: str = None,
                   session_type: str = 'personal') -> str:
    """Create a new session (personal or project)"""
    if not session_id:
        session_id = str(uuid.uuid4())

    now = datetime.now().isoformat()

    if not session_name:
        session_name = f"Discussion - {datetime.now().strftime('%Y-%m-%d %H:%M')}"

    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # Check if session already exists (for projects)
        cursor.execute("SELECT session_id FROM sessions WHERE session_id = ?", (session_id,))
        existing = cursor.fetchone()

        if existing:
            # Session already exists (project session), just return it
            conn.close()
            return session_id

        # Create new session
        cursor.execute("""
            INSERT INTO sessions (session_id, username, session_name, session_type, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (session_id, username, session_name, session_type, now, now))
        conn.commit()
        conn.close()

    return session_id


def update_session_metadata(session_id: str, meeting_date: str = None, meeting_time: str = None,
                            venue: str = None, agenda: str = None):
    """Update session metadata"""
    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        updates = []
        params = []

        if meeting_date is not None:
            updates.append("meeting_date = ?")
            params.append(meeting_date)
        if meeting_time is not None:
            updates.append("meeting_time = ?")
            params.append(meeting_time)
        if venue is not None:
            updates.append("venue = ?")
            params.append(venue)
        if agenda is not None:
            updates.append("agenda = ?")
            params.append(agenda)

        updates.append("updated_at = ?")
        params.append(datetime.now().isoformat())
        params.append(session_id)

        query = f"UPDATE sessions SET {', '.join(updates)} WHERE session_id = ?"
        cursor.execute(query, params)
        conn.commit()
        conn.close()


def save_result_to_session(session_id: str, mode: str, summary_length: str, result_text: str, result_order: int):
    """Save a result to a session"""
    result_id = str(uuid.uuid4())
    now = datetime.now().isoformat()

    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO session_results (result_id, session_id, mode, summary_length, result_text, result_order, created_at)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, (result_id, session_id, mode, summary_length, result_text, result_order, now))

        # Update session timestamp
        cursor.execute("""
            UPDATE sessions SET updated_at = ? WHERE session_id = ?
        """, (now, session_id))

        conn.commit()
        conn.close()

    return result_id


def get_session_results(session_id: str):
    """Get all results for a session"""
    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("""
            SELECT result_id, mode, summary_length, result_text, result_order, created_at
            FROM session_results
            WHERE session_id = ?
            ORDER BY result_order ASC
        """, (session_id,))

        results = []
        for row in cursor.fetchall():
            results.append({
                "result_id": row[0],
                "mode": row[1],
                "summary_length": row[2],
                "result_text": row[3],
                "result_order": row[4],
                "created_at": row[5]
            })

        conn.close()
        return results


def get_user_sessions(username: str):
    """Get all sessions for a user"""
    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("""
            SELECT s.session_id, s.session_name, s.meeting_date, s.meeting_time,
                   s.venue, s.agenda, s.created_at, s.updated_at,
                   COUNT(r.result_id) as result_count
            FROM sessions s
            LEFT JOIN session_results r ON s.session_id = r.session_id
            WHERE s.username = ?
            GROUP BY s.session_id
            ORDER BY s.updated_at DESC
        """, (username,))

        sessions = []
        for row in cursor.fetchall():
            sessions.append({
                "session_id": row[0],
                "session_name": row[1],
                "meeting_date": row[2],
                "meeting_time": row[3],
                "venue": row[4],
                "agenda": row[5],
                "created_at": row[6],
                "updated_at": row[7],
                "result_count": row[8]
            })

        conn.close()
        return sessions


def get_session_details(session_id: str):
    """Get full session details including metadata and results"""
    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # Get session metadata
        cursor.execute("""
            SELECT session_id, username, session_name, meeting_date, meeting_time,
                   venue, agenda, created_at, updated_at
            FROM sessions
            WHERE session_id = ?
        """, (session_id,))

        session_row = cursor.fetchone()
        if not session_row:
            conn.close()
            return None

        session_data = {
            "session_id": session_row[0],
            "username": session_row[1],
            "session_name": session_row[2],
            "meeting_date": session_row[3],
            "meeting_time": session_row[4],
            "venue": session_row[5],
            "agenda": session_row[6],
            "created_at": session_row[7],
            "updated_at": session_row[8]
        }

        conn.close()

    # Get results
    session_data["results"] = get_session_results(session_id)
    return session_data


def rename_session(session_id: str, new_name: str):
    """Rename a session"""
    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("""
            UPDATE sessions
            SET session_name = ?, updated_at = ?
            WHERE session_id = ?
        """, (new_name, datetime.now().isoformat(), session_id))
        conn.commit()
        conn.close()


def delete_session(session_id: str):
    """Delete a session and all its results"""
    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # Delete results first
        cursor.execute("DELETE FROM session_results WHERE session_id = ?", (session_id,))
        deleted_results = cursor.rowcount

        # Delete session
        cursor.execute("DELETE FROM sessions WHERE session_id = ?", (session_id,))
        deleted_sessions = cursor.rowcount

        conn.commit()
        conn.close()

        logger.info(f"Deleted {deleted_results} results and {deleted_sessions} session(s)")
        return deleted_sessions > 0


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    global model, processor, embedding_model
    try:
        logger.info("=" * 70)
        logger.info("Initializing sessions database...")
        initialize_sessions_database()
        initialize_project_sessions()

        logger.info("=" * 70)
        logger.info("Loading AI model...")
        logger.info("=" * 70)
        repo_id = "/Users/vishnukumarkudidela/Desktop/workspace/ASR/models/Voxtral-Mini-3B-2507"
        processor = AutoProcessor.from_pretrained(repo_id)
        model = VoxtralForConditionalGeneration.from_pretrained(
            repo_id, torch_dtype=torch.bfloat16, device_map=device
        )
        logger.info(f"‚úì Model loaded successfully on {device}")
        logger.info("=" * 70)

        # Load embedding model for RAG
        logger.info("Loading embedding model for RAG...")
        embedding_model = SentenceTransformer('all-MiniLM-L6-v2')
        logger.info("‚úì Embedding model loaded")
        logger.info("=" * 70)
    except Exception as e:
        logger.error(f"‚úó Failed to load model: {e}")
        raise

    yield

    # Shutdown
    logger.info("Shutting down GPU server...")


app = FastAPI(title="DEAIS GPU Server", version="1.0.0", lifespan=lifespan)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


class GlobalSummaryRequest(BaseModel):
    texts: List[str]
    session_id: Optional[str] = None


class SessionMetadataRequest(BaseModel):
    session_id: str
    meeting_date: Optional[str] = None
    meeting_time: Optional[str] = None
    venue: Optional[str] = None
    agenda: Optional[str] = None


class CreateQuerySessionRequest(BaseModel):
    username: str
    session_name: Optional[str] = None


class UpdateQuerySessionRequest(BaseModel):
    query_session_id: str
    selected_sessions: List[str]


class AskQuestionRequest(BaseModel):
    query_session_id: str
    question: str
    top_k: int = 5


@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "model_loaded": model is not None,
        "device": device,
        "timestamp": datetime.now().isoformat()
    }


@app.post("/create_session")
async def create_new_session(
    username: str = Form(...),
    session_name: str = Form(None),
    session_id: str = Form(None),
    session_type: str = Form('personal')
):
    """Create a new session"""
    try:
        new_session_id = create_session(
            username=username,
            session_name=session_name,
            session_id=session_id,
            session_type=session_type
        )
        logger.info(f"‚úì Created new session: {new_session_id} for user: {username}")
        return {
            "status": "success",
            "session_id": new_session_id,
            "message": "Session created successfully"
        }
    except Exception as e:
        logger.error(f"‚úó Error creating session: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/update_session_metadata")
async def update_metadata(request: SessionMetadataRequest):
    """Update session metadata"""
    try:
        update_session_metadata(
            request.session_id,
            request.meeting_date,
            request.meeting_time,
            request.venue,
            request.agenda
        )
        return {"status": "success", "message": "Metadata updated"}
    except Exception as e:
        logger.error(f"‚úó Error updating metadata: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/user_sessions/{username}")
async def get_sessions(username: str):
    """Get all sessions for a user"""
    try:
        sessions = get_user_sessions(username)
        return {
            "status": "success",
            "sessions": sessions
        }
    except Exception as e:
        logger.error(f"‚úó Error fetching sessions: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/session/{session_id}")
async def get_session(session_id: str):
    """Get full session details"""
    try:
        session_data = get_session_details(session_id)
        if not session_data:
            raise HTTPException(status_code=404, detail="Session not found")

        return {
            "status": "success",
            "session": session_data
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚úó Error fetching session: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/rename_session")
async def rename_session_endpoint(request: Request):
    """Rename a session"""
    try:
        body = await request.json()
        rename_session(body['session_id'], body['new_name'])
        return {"status": "success", "message": "Session renamed"}
    except Exception as e:
        logger.error(f"‚úó Error renaming session: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/delete_session")
async def delete_session_endpoint(request: Request):
    """Delete a session"""
    try:
        body = await request.json()
        session_id = body.get('session_id')

        if not session_id:
            logger.error("No session_id provided")
            raise HTTPException(status_code=400, detail="session_id is required")

        logger.info(f"Attempting to delete session: {session_id}")
        result = delete_session(session_id)

        if result:
            logger.info(f"‚úì Successfully deleted session: {session_id}")
            return {"status": "success", "message": "Session deleted"}
        else:
            logger.warning(f"Session not found: {session_id}")
            return {"status": "error", "message": "Session not found"}

    except Exception as e:
        logger.error(f"‚úó Error deleting session: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/project_session/{project_id}")
async def get_project_session(project_id: str):
    """Get or create a project-specific session"""
    try:
        with db_lock:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()

            # Check if project session exists
            cursor.execute("""
                SELECT session_id, session_name, meeting_date, meeting_time,
                       venue, agenda, created_at
                FROM sessions
                WHERE project_id = ? AND session_type = 'project'
                ORDER BY updated_at DESC
                LIMIT 1
            """, (project_id,))

            result = cursor.fetchone()

            if result:
                # Existing project session found
                session_id = result[0]
                session_data = {
                    'session_id': session_id,
                    'session_name': result[1] or f"{project_id.upper()} Project",
                    'meeting_date': result[2],
                    'meeting_time': result[3],
                    'venue': result[4],
                    'agenda': result[5],
                    'created_at': result[6]
                }
                logger.info(f"‚úì Found existing project session: {project_id}")
            else:
                # Create new project session
                session_id = str(uuid.uuid4())
                now = datetime.now().isoformat()
                session_name = f"{project_id.upper()} Project"

                cursor.execute("""
                    INSERT INTO sessions
                    (session_id, username, session_name, session_type,
                     project_id, created_at, updated_at)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                """, (session_id, 'system', session_name, 'project',
                      project_id, now, now))

                session_data = {
                    'session_id': session_id,
                    'session_name': session_name,
                    'meeting_date': None,
                    'meeting_time': None,
                    'venue': None,
                    'agenda': None,
                    'created_at': now
                }
                logger.info(f"‚úì Created new project session: {project_id} -> {session_id}")

            # Get all results for this session
            cursor.execute("""
                SELECT mode, summary_length, result_text, result_order, created_at
                FROM session_results
                WHERE session_id = ?
                ORDER BY result_order ASC
            """, (session_id,))

            results = []
            for row in cursor.fetchall():
                results.append({
                    'mode': row[0],
                    'summary_length': row[1],
                    'result_text': row[2],
                    'result_order': row[3],
                    'created_at': row[4]
                })

            session_data['results'] = results

            conn.commit()
            conn.close()

            return {
                "status": "success",
                "session": session_data
            }

    except Exception as e:
        logger.error(f"‚úó Error in get_project_session: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        raise HTTPException(status_code=500, detail=str(e))

def extract_text_from_pdf(file_content: bytes) -> str:
    """Extract text from PDF file"""
    try:
        import io
        pdf_file = io.BytesIO(file_content)
        pdf_reader = PyPDF2.PdfReader(pdf_file)

        text = ""
        for page in pdf_reader.pages:
            text += page.extract_text() + "\n\n"

        return text.strip()
    except Exception as e:
        logger.error(f"Error extracting PDF text: {str(e)}")
        return ""


def extract_text_from_docx(file_content: bytes) -> str:
    """Extract text from DOCX file"""
    try:
        import io
        doc_file = io.BytesIO(file_content)
        doc = docx.Document(doc_file)

        text = ""
        for paragraph in doc.paragraphs:
            text += paragraph.text + "\n"

        return text.strip()
    except Exception as e:
        logger.error(f"Error extracting DOCX text: {str(e)}")
        return ""


def extract_text_from_txt(file_content: bytes) -> str:
    """Extract text from TXT file"""
    try:
        return file_content.decode('utf-8')
    except Exception as e:
        logger.error(f"Error extracting TXT text: {str(e)}")
        return ""


def chunk_text(text: str, chunk_size: int = 500, overlap: int = 100) -> List[str]:
    """Split text into overlapping chunks"""
    words = text.split()
    chunks = []

    for i in range(0, len(words), chunk_size - overlap):
        chunk = ' '.join(words[i:i + chunk_size])
        if len(chunk.strip()) > 50:  # Skip very short chunks
            chunks.append(chunk.strip())

    return chunks


def get_embeddings(texts: List[str]) -> np.ndarray:
    """Generate embeddings for texts"""
    if not embedding_model:
        raise Exception("Embedding model not loaded")
    return embedding_model.encode(texts)


def find_relevant_chunks(query: str, chunks_data: List[Dict], top_k: int = 5) -> List[Dict]:
    """Find most relevant chunks using semantic search"""
    if not chunks_data:
        return []

    # Generate embeddings
    query_embedding = get_embeddings([query])[0]
    chunk_texts = [c['text'] for c in chunks_data]
    chunk_embeddings = get_embeddings(chunk_texts)

    # Calculate cosine similarity
    similarities = np.dot(chunk_embeddings, query_embedding) / (
            np.linalg.norm(chunk_embeddings, axis=1) * np.linalg.norm(query_embedding)
    )

    # Get top-k most similar
    top_indices = np.argsort(similarities)[-top_k:][::-1]

    relevant_chunks = []
    for idx in top_indices:
        if similarities[idx] > 0.3:  # Threshold for relevance
            relevant_chunks.append({
                **chunks_data[idx],
                'similarity': float(similarities[idx])
            })

    return relevant_chunks


def create_query_session(username: str, session_name: str = None) -> str:
    """Create a new query session"""
    query_session_id = str(uuid.uuid4())
    now = datetime.now().isoformat()

    if not session_name:
        session_name = f"Query Session - {datetime.now().strftime('%Y-%m-%d %H:%M')}"

    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO query_sessions (query_session_id, username, session_name, selected_sessions, uploaded_documents, created_at, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, (query_session_id, username, session_name, "[]", "[]", now, now))
        conn.commit()
        conn.close()

    return query_session_id


def update_query_session_selections(query_session_id: str, selected_sessions: List[str]):
    """Update selected sessions for a query session"""
    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("""
            UPDATE query_sessions
            SET selected_sessions = ?, updated_at = ?
            WHERE query_session_id = ?
        """, (json.dumps(selected_sessions), datetime.now().isoformat(), query_session_id))
        conn.commit()
        conn.close()


def save_uploaded_document(query_session_id: str, filename: str, content: str) -> str:
    """Save uploaded document content"""
    document_id = str(uuid.uuid4())
    now = datetime.now().isoformat()

    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO uploaded_documents (document_id, query_session_id, filename, content, created_at)
            VALUES (?, ?, ?, ?, ?)
        """, (document_id, query_session_id, filename, content, now))

        # Update query session's uploaded_documents list
        cursor.execute("""
            SELECT uploaded_documents FROM query_sessions WHERE query_session_id = ?
        """, (query_session_id,))
        result = cursor.fetchone()
        if result:
            docs = json.loads(result[0])
            docs.append({"document_id": document_id, "filename": filename})
            cursor.execute("""
                UPDATE query_sessions
                SET uploaded_documents = ?, updated_at = ?
                WHERE query_session_id = ?
            """, (json.dumps(docs), datetime.now().isoformat(), query_session_id))

        conn.commit()
        conn.close()

    return document_id


def get_query_session_data(query_session_id: str) -> Dict:
    """Get all data for a query session"""
    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # Get query session info
        cursor.execute("""
            SELECT query_session_id, username, session_name, selected_sessions, uploaded_documents, created_at
            FROM query_sessions
            WHERE query_session_id = ?
        """, (query_session_id,))

        row = cursor.fetchone()
        if not row:
            conn.close()
            return None

        query_session = {
            "query_session_id": row[0],
            "username": row[1],
            "session_name": row[2],
            "selected_sessions": json.loads(row[3]),
            "uploaded_documents": json.loads(row[4]),
            "created_at": row[5]
        }

        # Get Q&A history
        cursor.execute("""
            SELECT qa_id, question, answer, sources, created_at
            FROM qa_history
            WHERE query_session_id = ?
            ORDER BY created_at ASC
        """, (query_session_id,))

        qa_history = []
        for qa_row in cursor.fetchall():
            qa_history.append({
                "qa_id": qa_row[0],
                "question": qa_row[1],
                "answer": qa_row[2],
                "sources": json.loads(qa_row[3]) if qa_row[3] else [],
                "created_at": qa_row[4]
            })

        query_session["qa_history"] = qa_history

        conn.close()
        return query_session


def get_user_query_sessions(username: str) -> List[Dict]:
    """Get all query sessions for a user"""
    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("""
            SELECT q.query_session_id, q.session_name, q.selected_sessions, q.uploaded_documents, q.created_at, q.updated_at,
                   COUNT(qa.qa_id) as qa_count
            FROM query_sessions q
            LEFT JOIN qa_history qa ON q.query_session_id = qa.query_session_id
            WHERE q.username = ?
            GROUP BY q.query_session_id
            ORDER BY q.updated_at DESC
        """, (username,))

        sessions = []
        for row in cursor.fetchall():
            sessions.append({
                "query_session_id": row[0],
                "session_name": row[1],
                "selected_sessions": json.loads(row[2]),
                "uploaded_documents": json.loads(row[3]),
                "created_at": row[4],
                "updated_at": row[5],
                "qa_count": row[6]
            })

        conn.close()
        return sessions


def save_qa_to_history(query_session_id: str, question: str, answer: str, sources: List[Dict]) -> str:
    """Save Q&A to history"""
    qa_id = str(uuid.uuid4())
    now = datetime.now().isoformat()

    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO qa_history (qa_id, query_session_id, question, answer, sources, created_at)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (qa_id, query_session_id, question, answer, json.dumps(sources), now))

        # Update query session timestamp
        cursor.execute("""
            UPDATE query_sessions SET updated_at = ? WHERE query_session_id = ?
        """, (now, query_session_id))

        conn.commit()
        conn.close()

    return qa_id


def delete_query_session(query_session_id: str):
    """Delete a query session and all its data"""
    with db_lock:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()

        # Delete Q&A history
        cursor.execute("DELETE FROM qa_history WHERE query_session_id = ?", (query_session_id,))

        # Delete uploaded documents
        cursor.execute("DELETE FROM uploaded_documents WHERE query_session_id = ?", (query_session_id,))

        # Delete query session
        cursor.execute("DELETE FROM query_sessions WHERE query_session_id = ?", (query_session_id,))

        conn.commit()
        conn.close()


@app.post("/process_audio")
async def process_audio(
        background_tasks: BackgroundTasks,
        file: UploadFile = File(...),
        mode: str = Form(...),
        summary_length: str = Form(default="Medium"),
        session_id: str = Form(...),
        result_order: int = Form(...)
):
    """Process uploaded audio file for transcription, summary, or action points"""
    if not model or not processor:
        raise HTTPException(status_code=503, detail="Model not loaded")

    # Validate mode
    valid_modes = ["Transcription", "Summary", "Action Points"]
    if mode not in valid_modes:
        raise HTTPException(status_code=400, detail=f"Invalid mode. Must be one of {valid_modes}")

    job_id = str(uuid.uuid4())
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    file_path = RECORDINGS_DIR / f"{timestamp}_{mode.replace(' ', '_')}_{file.filename}"

    # Save uploaded file
    try:
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)
        logger.info(f"‚úì Saved audio file: {file_path}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to save file: {str(e)}")

    # Create job entry
    jobs[job_id] = {
        "job_id": job_id,
        "status": "processing",
        "mode": mode,
        "summary_length": summary_length if mode == "Summary" else None,
        "result": None,
        "error": None,
        "created_at": datetime.now().isoformat(),
        "completed_at": None,
        "file_path": str(file_path),
        "session_id": session_id,
        "result_order": result_order
    }

    # Process in background
    background_tasks.add_task(process_audio_task, job_id, str(file_path), mode, summary_length, session_id,
                              result_order)

    logger.info(f"‚úì Job {job_id} created - Mode: {mode}, Length: {summary_length}, Session: {session_id}")

    return {
        "job_id": job_id,
        "status": "processing",
        "mode": mode,
        "message": f"Processing audio with mode: {mode}"
    }


async def process_audio_task(job_id: str, file_path: str, mode: str, summary_length: str, session_id: str,
                             result_order: int):
    """Background task to process audio"""
    try:
        logger.info(f"‚úì Starting processing for job {job_id} - Mode: {mode}")

        if mode == "Transcription":
            logger.info(f"‚úì Processing Transcription for {job_id}")
            inputs = processor.apply_transcription_request(
                language="en",
                audio=file_path,
                model_id="/Users/vishnukumarkudidela/Desktop/workspace/ASR/models/Voxtral-Mini-3B-2507"
            )
            inputs = inputs.to(device, dtype=torch.bfloat16)
            outputs = model.generate(**inputs, max_new_tokens=4096)
            decoded = processor.batch_decode(
                outputs[:, inputs.input_ids.shape[1]:],
                skip_special_tokens=True
            )
            result = f"[TRANSCRIPTION]\n\n{decoded[0]}"

        elif mode == "Summary":
            logger.info(f"‚úì Processing Summary ({summary_length}) for {job_id}")
            instructions = {
                "Short": "generate a short, concise summary",
                "Medium": "generate a medium-length, detailed summary",
                "Long": "generate a comprehensive, long-form summary"
            }
            instruction = instructions.get(summary_length, instructions["Medium"])

            conversation = [{
                "role": "user",
                "content": [{
                    "type": "text",
                    "text": (
                        f"You are a helpful assistant that works in summarizer mode.don't react to any conversations or questions in the audio.Summarize audio to text only "
                        f"After listening to the audio, please understand the total audio, "
                        f"then {instruction} that should be organised topic-wise, with clear things, "
                        f"within the audio by utilizing entire input audio. "
                        f"Do not use numbered lists (1., 2., 3., etc.). Use only the ‚û§ symbol for all summary modes.\n"
                        f"Don't go for hallucinations and extended sentences which are not in the audio. "
                        f"Keep the summary within provided audio only."
                    )
                }]
            }, {
                "role": "user",
                "content": [{"type": "audio", "path": file_path}]
            }]

            inputs = processor.apply_chat_template(conversation)
            inputs = inputs.to(device, dtype=torch.bfloat16)
            outputs = model.generate(**inputs, max_new_tokens=2048)
            decoded = processor.batch_decode(
                outputs[:, inputs.input_ids.shape[1]:],
                skip_special_tokens=True
            )
            result = f"[SUMMARY - {summary_length}]\n\n{decoded[0]}"

        elif mode == "Action Points":
            logger.info(f"‚úì Processing Action Points for {job_id}")
            conversation = [{
                "role": "user",
                "content": [{
                    "type": "text",
                    "text": (
                        "You are a helpful assistant that works in action points extraction mode. "
                        "After listening the audio, extract all key action points. "
                        "Each action point should clearly state:\n"
                        "- The task or decision\n"
                        "- Who is responsible\n"
                        "- The deadline or timeline (if mentioned)\n"
                        "- Any dependencies or resources needed\n"
                        "Present the output using the ‚û§ symbol for each action point instead of numbers.\n"
                        "Format each action point exactly like this:\n"
                        "‚û§ Task/Decision: [description]\n"
                        "  ‚Ä¢ Responsible: [person]\n"
                        "  ‚Ä¢ Deadline: [date/timeline]\n\n"
                        "Do not use numbered lists (1., 2., 3., etc.). Use only the ‚û§ symbol for each action point.\n"
                        "If audio has no action points, then give the text you understood clearly."
                    )
                }]
            }, {
                "role": "user",
                "content": [{"type": "audio", "path": file_path}]
            }]

            inputs = processor.apply_chat_template(conversation)
            inputs = inputs.to(device, dtype=torch.bfloat16)
            outputs = model.generate(**inputs, max_new_tokens=2048)
            decoded = processor.batch_decode(
                outputs[:, inputs.input_ids.shape[1]:],
                skip_special_tokens=True
            )
            result = f"[ACTION POINTS]\n\n{decoded[0]}"

        # Update job status
        jobs[job_id]["status"] = "completed"
        jobs[job_id]["result"] = result
        jobs[job_id]["completed_at"] = datetime.now().isoformat()

        # Save to session
        save_result_to_session(session_id, mode, summary_length, result, result_order)

        logger.info(f"‚úì Job {job_id} completed and saved to session {session_id}")

    except Exception as e:
        logger.error(f"‚úó Job {job_id} failed: {str(e)}")
        jobs[job_id]["status"] = "error"
        jobs[job_id]["error"] = str(e)
        jobs[job_id]["completed_at"] = datetime.now().isoformat()

    finally:
        # AUTOMATICALLY DELETE THE AUDIO FILE AFTER PROCESSING
        try:
            if os.path.exists(file_path):
                os.remove(file_path)
                logger.info(f"‚úì Auto-deleted temporary audio file: {file_path}")
        except Exception as e:
            logger.error(f"Failed to delete file {file_path}: {str(e)}")


@app.get("/job_status/{job_id}")
async def get_job_status(job_id: str):
    """Check the status of a processing job"""
    if job_id not in jobs:
        raise HTTPException(status_code=404, detail="Job not found")

    job_data = jobs[job_id].copy()
    # Don't send file_path to client
    if "file_path" in job_data:
        del job_data["file_path"]

    return job_data


@app.post("/global_summary")
async def generate_global_summary(request: GlobalSummaryRequest):
    """Generate a global summary from multiple text results"""
    if not model or not processor:
        raise HTTPException(status_code=503, detail="Model not loaded")

    if not request.texts:
        raise HTTPException(status_code=400, detail="No texts provided")

    try:
        # Filter out transcriptions, keep only summaries and action points
        filtered = [t for t in request.texts if not t.strip().startswith("[TRANSCRIPTION]")]

        if not filtered:
            raise HTTPException(status_code=400, detail="No valid summaries or action points to process")

        combined = "\n\n".join(filtered)

        conversation = [{
            "role": "user",
            "content": [{
                "type": "text",
                "text": (
                    "You are an expert meeting summarizer. Your task is to create a comprehensive global summary "
                    "from multiple meeting segments.\n\n"

                    "INSTRUCTIONS:\n"
                    "1. Read and analyze all the provided text segments carefully\n"
                    "2. Identify and group related topics across all segments\n"
                    "3. Create a cohesive, well-organized summary that covers ALL topics discussed\n"
                    "4. Maintain chronological flow when relevant\n"
                    "5. Preserve important details, decisions, and discussions\n"
                    "6. Remove redundancies while keeping unique information from each segment\n"
                    "7. don't repeat the sentences keep as unique\n\n"

                    "OUTPUT STRUCTURE:\n"
                    "- Start with an 'OVERVIEW' section (2-3 sentences about the overall meeting)\n"
                    "- Organize content by TOPICS with clear headings\n"
                    "- Under each topic, provide key points and discussions\n"
                    "- Include a 'KEY DECISIONS' section if any decisions were made\n"
                    "- End with 'ACTION ITEMS' section if action points exist\n\n"

                    "IMPORTANT GUIDELINES:\n"
                    "- Do NOT add information not present in the original text\n"
                    "- Do NOT miss any important topics, even if briefly mentioned\n"
                    "- Use clear, professional language\n"
                    "- Be concise but comprehensive\n"
                    "- don't repeat the sentences keep as unique\n"
                    "- don't add action points twice in global summary\n"
                    "- If a topic appears in multiple segments, consolidate it intelligently\n\n"

                    f"TEXT TO SUMMARIZE:\n\n{combined}"
                )
            }]
        }]

        inputs = processor.apply_chat_template(conversation)
        inputs = inputs.to(device, dtype=torch.bfloat16)
        outputs = model.generate(**inputs, max_new_tokens=4096)
        decoded = processor.batch_decode(
            outputs[:, inputs.input_ids.shape[1]:],
            skip_special_tokens=True
        )

        global_summary = decoded[0]

        # Save to session if provided
        if request.session_id:
            # Get current result count for ordering
            results = get_session_results(request.session_id)
            result_order = len(results) + 1
            save_result_to_session(request.session_id, "GLOBAL SUMMARY", None, global_summary, result_order)
            logger.info(f"‚úì Global summary saved to session {request.session_id}")

        logger.info("‚úì Global summary generated successfully")

        return {
            "status": "success",
            "global_summary": global_summary
        }

    except Exception as e:
        logger.error(f"‚úó Global summary generation failed: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/create_query_session")
async def create_query_session_endpoint(request: CreateQuerySessionRequest):
    """Create a new query session"""
    try:
        query_session_id = create_query_session(request.username, request.session_name)
        logger.info(f"‚úì Created query session: {query_session_id}")
        return {
            "status": "success",
            "query_session_id": query_session_id
        }
    except Exception as e:
        logger.error(f"‚úó Error creating query session: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/update_query_session_selections")
async def update_query_session_selections_endpoint(request: UpdateQuerySessionRequest):
    """Update selected sessions for query session"""
    try:
        update_query_session_selections(request.query_session_id, request.selected_sessions)
        return {"status": "success"}
    except Exception as e:
        logger.error(f"‚úó Error updating selections: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/upload_document")
async def upload_document_endpoint(
        query_session_id: str = Form(...),
        file: UploadFile = File(...)
):
    """Upload and process document for query session"""
    try:
        # Read file content
        content = await file.read()

        # Extract text based on file type
        filename = file.filename.lower()
        if filename.endswith('.pdf'):
            text_content = extract_text_from_pdf(content)
        elif filename.endswith('.docx'):
            text_content = extract_text_from_docx(content)
        elif filename.endswith('.txt'):
            text_content = extract_text_from_txt(content)
        else:
            raise HTTPException(status_code=400, detail="Unsupported file type. Use PDF, DOCX, or TXT")

        if not text_content:
            raise HTTPException(status_code=400, detail="Could not extract text from document")

        # Save to database
        document_id = save_uploaded_document(query_session_id, file.filename, text_content)

        logger.info(f"‚úì Uploaded document: {file.filename} for query session {query_session_id}")

        return {
            "status": "success",
            "document_id": document_id,
            "filename": file.filename,
            "content_length": len(text_content)
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚úó Error uploading document: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/query_session/{query_session_id}")
async def get_query_session_endpoint(query_session_id: str):
    """Get query session data with history"""
    try:
        data = get_query_session_data(query_session_id)
        if not data:
            raise HTTPException(status_code=404, detail="Query session not found")

        return {
            "status": "success",
            "query_session": data
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚úó Error fetching query session: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/user_query_sessions/{username}")
async def get_user_query_sessions_endpoint(username: str):
    """Get all query sessions for a user"""
    try:
        sessions = get_user_query_sessions(username)
        return {
            "status": "success",
            "query_sessions": sessions
        }
    except Exception as e:
        logger.error(f"‚úó Error fetching query sessions: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/ask_question")
async def ask_question_endpoint(request: AskQuestionRequest):
    """Answer question using RAG from a single selected session - WITH DETAILED LOGGING"""

    if not model or not processor or not embedding_model:
        raise HTTPException(status_code=503, detail="Models not loaded")

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # STEP 0: INITIALIZE TIMING AND LOGGING
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    logger.info("=" * 100)
    logger.info("üöÄ NEW QUESTION RECEIVED")
    logger.info("=" * 100)
    logger.info(f"üìù Question: {request.question}")
    logger.info(f"üÜî Session ID: {request.query_session_id}")
    logger.info(f"üî¢ Top K: {request.top_k}")

    overall_start = time.perf_counter()
    query_logger.start_interaction()

    try:
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # STEP 1: FETCH SESSION DATA
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        logger.info("\n" + "‚îÄ" * 100)
        logger.info("üìÇ STEP 1: FETCHING SESSION DATA")
        logger.info("‚îÄ" * 100)

        step_start = time.perf_counter()
        selected_session_id = request.query_session_id
        session_details = get_session_details(selected_session_id)

        if not session_details:
            logger.error("‚ùå Session not found!")
            return {
                "status": "error",
                "answer": "Selected session not found.",
                "sources": [],
                "qa_id": None
            }

        session_name = session_details['session_name'] or "Unknown Session"
        session_results = session_details['results']

        logger.info(f"‚úÖ Session loaded: {session_name}")
        logger.info(f"üìä Total results in session: {len(session_results)}")
        logger.info(f"‚è±Ô∏è  Session fetch time: {(time.perf_counter() - step_start) * 1000:.2f}ms")

        if not session_results:
            logger.warning("‚ö†Ô∏è  Session has no results!")
            return {
                "status": "success",
                "answer": "This session has no results yet.",
                "sources": [],
                "qa_id": None
            }

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # STEP 2: EXTRACT AND CHUNK TEXT
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        logger.info("\n" + "‚îÄ" * 100)
        logger.info("üìÑ STEP 2: EXTRACTING AND CHUNKING TEXT")
        logger.info("‚îÄ" * 100)

        step_start = time.perf_counter()
        chunks_data = []

        for idx, result in enumerate(session_results):
            logger.info(f"\n  Processing result #{idx + 1}:")
            logger.info(f"    ‚Ä¢ Mode: {result['mode']}")
            logger.info(f"    ‚Ä¢ Order: {result['result_order']}")

            # Clean the text
            text = result['result_text']
            original_length = len(text)

            text = text.replace('[SUMMARY - Short]', '').replace('[SUMMARY - Medium]', '').replace('[SUMMARY - Long]',
                                                                                                   '')
            text = text.replace('[ACTION POINTS]', '').replace('[GLOBAL SUMMARY]', '').replace('[TRANSCRIPTION]', '')
            text = text.strip()

            logger.info(f"    ‚Ä¢ Original text length: {original_length} chars")
            logger.info(f"    ‚Ä¢ Cleaned text length: {len(text)} chars")

            # Split into paragraphs/chunks
            paragraphs = text.split('\n\n')
            chunks_added = 0

            for para_idx, para in enumerate(paragraphs):
                para = para.strip()
                if len(para) > 50:  # Only keep substantial chunks
                    chunks_data.append({
                        'text': para,
                        'source_type': 'session_result',
                        'source_name': f"{session_name} - {result['mode']}",
                        'session_id': selected_session_id,
                        'mode': result['mode'],
                        'result_order': result['result_order'],
                        'chunk_id': f"R{idx + 1}_C{para_idx + 1}"
                    })
                    chunks_added += 1

                    # Log first 100 chars of each chunk
                    preview = para[:100] + "..." if len(para) > 100 else para
                    logger.info(f"    ‚Ä¢ Chunk {chunks_added}: {preview}")

            logger.info(f"    ‚úÖ Added {chunks_added} chunks from this result")

        chunk_extraction_time = time.perf_counter() - step_start
        query_logger.add_timing("chunk_extraction", chunk_extraction_time)

        logger.info(f"\nüì¶ Total chunks extracted: {len(chunks_data)}")
        logger.info(f"‚è±Ô∏è  Chunk extraction time: {chunk_extraction_time * 1000:.2f}ms")

        if not chunks_data:
            logger.warning("‚ö†Ô∏è  No text content found in session!")
            return {
                "status": "success",
                "answer": "No text content found in this session.",
                "sources": [],
                "qa_id": None
            }

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # STEP 3: GENERATE QUERY EMBEDDING
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        logger.info("\n" + "‚îÄ" * 100)
        logger.info("üß† STEP 3: GENERATING QUERY EMBEDDING")
        logger.info("‚îÄ" * 100)

        step_start = time.perf_counter()
        logger.info(f"üìù Query: {request.question}")
        logger.info(f"üîß Embedding model: all-MiniLM-L6-v2")

        query_embedding = get_embeddings([request.question])[0]

        query_embedding_time = time.perf_counter() - step_start
        query_logger.add_timing("query_embedding", query_embedding_time)

        logger.info(f"‚úÖ Query embedding generated")
        logger.info(f"üìê Embedding dimension: {len(query_embedding)}")
        logger.info(f"‚è±Ô∏è  Embedding time: {query_embedding_time * 1000:.2f}ms")

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # STEP 4: SEMANTIC SEARCH (MOST IMPORTANT!)
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        logger.info("\n" + "‚îÄ" * 100)
        logger.info("üîç STEP 4: SEMANTIC SEARCH - FINDING RELEVANT CHUNKS")
        logger.info("‚îÄ" * 100)

        step_start = time.perf_counter()

        # Generate embeddings for all chunks
        logger.info(f"üßÆ Generating embeddings for {len(chunks_data)} chunks...")
        chunk_texts = [c['text'] for c in chunks_data]
        chunk_embeddings = get_embeddings(chunk_texts)
        logger.info(f"‚úÖ Chunk embeddings generated")

        # Calculate cosine similarity
        logger.info(f"üìä Calculating cosine similarities...")
        similarities = np.dot(chunk_embeddings, query_embedding) / (
                np.linalg.norm(chunk_embeddings, axis=1) * np.linalg.norm(query_embedding)
        )

        # Get top-k most similar
        top_indices = np.argsort(similarities)[-request.top_k:][::-1]

        logger.info(f"\nüìà SIMILARITY SCORES (All chunks):")
        logger.info(f"   Min: {similarities.min():.4f}")
        logger.info(f"   Max: {similarities.max():.4f}")
        logger.info(f"   Mean: {similarities.mean():.4f}")
        logger.info(f"   Median: {np.median(similarities):.4f}")

        # Build relevant chunks list
        relevant_chunks = []
        logger.info(f"\nüéØ TOP {request.top_k} RELEVANT CHUNKS:")
        logger.info("‚îÄ" * 100)

        for rank, idx in enumerate(top_indices, 1):
            similarity_score = float(similarities[idx])

            if similarity_score > 0.3:  # Threshold for relevance
                chunk = chunks_data[idx]
                chunk_with_score = {
                    **chunk,
                    'similarity': similarity_score
                }
                relevant_chunks.append(chunk_with_score)

                # Detailed logging for each retrieved chunk
                logger.info(f"\n  Rank #{rank}:")
                logger.info(f"    üÜî Chunk ID: {chunk['chunk_id']}")
                logger.info(f"    üìä Similarity Score: {similarity_score:.4f}")
                logger.info(f"    üìÇ Source: {chunk['source_name']}")
                logger.info(f"    üìÑ Mode: {chunk['mode']}")
                logger.info(f"    üî¢ Result Order: {chunk['result_order']}")
                logger.info(f"    üìù Text Preview (first 200 chars):")
                preview = chunk['text'][:200] + "..." if len(chunk['text']) > 200 else chunk['text']
                logger.info(f"       {preview}")
                logger.info(f"    üìè Full text length: {len(chunk['text'])} chars")
            else:
                logger.info(f"\n  Rank #{rank}: Similarity {similarity_score:.4f} (below threshold 0.3, skipped)")

        semantic_search_time = time.perf_counter() - step_start
        query_logger.add_timing("semantic_search", semantic_search_time)

        logger.info(f"\n‚úÖ Retrieved {len(relevant_chunks)} relevant chunks (above 0.3 threshold)")
        logger.info(f"‚è±Ô∏è  Semantic search time: {semantic_search_time * 1000:.2f}ms")

        # Initialize variables for both paths
        context = ""
        context_construction_time = 0
        llm_generation_time = 0
        first_token_time = 0

        if not relevant_chunks:
            logger.warning("‚ö†Ô∏è  No relevant chunks found above threshold!")
            answer = "I couldn't find relevant information to answer your question."
            sources = []
        else:
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # STEP 5: CONSTRUCT CONTEXT FOR LLM
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            logger.info("\n" + "‚îÄ" * 100)
            logger.info("üìù STEP 5: CONSTRUCTING CONTEXT FOR LLM")
            logger.info("‚îÄ" * 100)

            step_start = time.perf_counter()
            context_parts = []

            for i, chunk in enumerate(relevant_chunks, 1):
                source_label = f"[Source {i}: {chunk['source_name']}]"
                context_part = f"{source_label}\n{chunk['text']}"
                context_parts.append(context_part)

                logger.info(f"\n  Context Part {i}:")
                logger.info(f"    üìÇ {source_label}")
                logger.info(f"    üìä Similarity: {chunk['similarity']:.4f}")
                logger.info(f"    üìè Length: {len(chunk['text'])} chars")

            context = "\n\n".join(context_parts)

            context_construction_time = time.perf_counter() - step_start
            query_logger.add_timing("context_construction", context_construction_time)

            logger.info(f"\n‚úÖ Context constructed")
            logger.info(f"üìè Total context length: {len(context)} chars")
            logger.info(f"üì¶ Number of sources: {len(relevant_chunks)}")
            logger.info(f"‚è±Ô∏è  Context construction time: {context_construction_time * 1000:.2f}ms")

            # Log the full prompt (optional - can be very long)
            logger.info(f"\nüìã FULL PROMPT TO LLM:")
            logger.info("‚îÄ" * 100)
            logger.info(f"SESSION: {session_name}\n")
            logger.info(f"CONTEXT FROM MEETING:\n{context}\n")
            logger.info(f"QUESTION: {request.question}")
            logger.info("‚îÄ" * 100)

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # STEP 6: LLM GENERATION
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            logger.info("\n" + "‚îÄ" * 100)
            logger.info("ü§ñ STEP 6: LLM ANSWER GENERATION")
            logger.info("‚îÄ" * 100)

            llm_start = time.perf_counter()

            conversation = [{
                "role": "user",
                "content": [{
                    "type": "text",
                    "text": (
                        f"You are a helpful assistant answering questions about a meeting session.\n\n"
                        f"SESSION: {session_name}\n\n"
                        f"CONTEXT FROM MEETING:\n{context}\n\n"
                        f"QUESTION: {request.question}\n\n"
                        f"INSTRUCTIONS:\n"
                        f"- Answer the question based ONLY on the provided meeting context\n"
                        f"- If the context doesn't contain enough information, clearly state what's missing\n"
                        f"- Be specific and reference which parts of the meeting support your answer\n"
                        f"- Use bullet points (‚Ä¢) for listing multiple points\n"
                        f"- Be conversational but professional\n"
                        f"- If asked about action items, decisions, or specific topics, quote relevant parts\n"
                        f"- Don't make up information not in the context\n"
                        f"- Keep answers concise but complete"
                        f"- Use plain text formatting only\n"
                        f"- Do NOT use markdown symbols like **, ##, _, etc.\n"
                        f"- For lists, use simple dashes (-) or numbers (1., 2., 3.)\n"
                        f"- For emphasis, use CAPITAL LETTERS instead of bold\n"
                    )
                }]
            }]

            # logger.info(f"üîß Model: Voxtral-Mini-3B")
            # logger.info(f"üéØ Max new tokens: 1024")
            # logger.info(f"‚ö° Starting generation...")

            inputs = processor.apply_chat_template(conversation)
            inputs = inputs.to(device, dtype=torch.bfloat16)

            # Time first token
            generation_start = time.perf_counter()
            outputs = model.generate(**inputs, max_new_tokens=1024)
            first_token_time = time.perf_counter() - generation_start

            decoded = processor.batch_decode(
                outputs[:, inputs.input_ids.shape[1]:],
                skip_special_tokens=True
            )

            answer = decoded[0]
            llm_generation_time = time.perf_counter() - llm_start
            query_logger.add_timing("llm_generation", llm_generation_time)

            logger.info(f"‚úÖ Answer generated")
            logger.info(f"‚è±Ô∏è  First token latency: {first_token_time * 1000:.2f}ms")
            logger.info(f"‚è±Ô∏è  Total generation time: {llm_generation_time * 1000:.2f}ms")
            logger.info(f"üìè Answer length: {len(answer)} chars")
            logger.info(f"\nüí¨ GENERATED ANSWER:")
            logger.info("‚îÄ" * 100)
            logger.info(answer)
            logger.info("‚îÄ" * 100)

            # Prepare sources
            sources = [{
                'source_type': chunk['source_type'],
                'source_name': chunk['source_name'],
                'text_snippet': chunk['text'][:200] + "..." if len(chunk['text']) > 200 else chunk['text'],
                'similarity': round(chunk['similarity'], 3)
            } for chunk in relevant_chunks]

        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # STEP 7: FINAL LOGGING AND SUMMARY
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        total_time = time.perf_counter() - overall_start

        logger.info("\n" + "=" * 100)
        logger.info("üìä PERFORMANCE SUMMARY")
        logger.info("=" * 100)
        logger.info(f"‚è±Ô∏è  Total time: {total_time * 1000:.2f}ms ({total_time:.2f}s)")
        logger.info(
            f"   ‚îú‚îÄ Chunk extraction: {chunk_extraction_time * 1000:.2f}ms ({chunk_extraction_time / total_time * 100:.1f}%)")
        logger.info(
            f"   ‚îú‚îÄ Query embedding: {query_embedding_time * 1000:.2f}ms ({query_embedding_time / total_time * 100:.1f}%)")
        logger.info(
            f"   ‚îú‚îÄ Semantic search: {semantic_search_time * 1000:.2f}ms ({semantic_search_time / total_time * 100:.1f}%)")
        if relevant_chunks:
            logger.info(
                f"   ‚îú‚îÄ Context construction: {context_construction_time * 1000:.2f}ms ({context_construction_time / total_time * 100:.1f}%)")
            logger.info(
                f"   ‚îî‚îÄ LLM generation: {llm_generation_time * 1000:.2f}ms ({llm_generation_time / total_time * 100:.1f}%)")

        logger.info(f"\nüìà DATA SUMMARY:")
        logger.info(f"   ‚Ä¢ Total chunks extracted: {len(chunks_data)}")
        logger.info(f"   ‚Ä¢ Relevant chunks retrieved: {len(relevant_chunks)}")
        logger.info(f"   ‚Ä¢ Context size: {len(context)} chars")
        logger.info(f"   ‚Ä¢ Answer size: {len(answer)} chars")

        # Prepare retrieval stats for QueryLogger
        retrieval_stats = {
            'chunks_extracted': len(chunks_data),
            'chunk_sources': f"{sum(1 for c in chunks_data if 'Summary' in c['source_name'])} summaries, "
                             f"{sum(1 for c in chunks_data if 'Action' in c['source_name'])} action points",
            'embedding_model': 'all-MiniLM-L6-v2',
            'vector_dim': 384,
            'top_k': request.top_k,
            'similarity_scores': [c['similarity'] for c in relevant_chunks] if relevant_chunks else [],
            'chunks_used': len(relevant_chunks),
            'context_length': len(context),
            'llm_model': 'Voxtral-Mini-3B',
            'first_token_latency': first_token_time
        }

        # Log to QueryLogger (structured logging)
        query_logger.log_query_interaction(
            username="system",
            session_id=selected_session_id,
            session_name=session_name,
            query=request.question,
            answer=answer,
            remote_ip="localhost",
            session_metadata={
                'result_count': len(session_results),
                'meeting_date': session_details.get('meeting_date', '')
            },
            retrieval_stats=retrieval_stats,
            sources=sources,
            timing_details=query_logger.current_timing_details,
            status="SUCCESS"
        )

        # Log chunks if enabled - FIXED VERSION
        if relevant_chunks:
            chunks_for_logging = []
            for chunk in relevant_chunks:
                # Find original index by matching chunk_id
                original_idx = next((i for i, c in enumerate(chunks_data) if c['chunk_id'] == chunk['chunk_id']), -1)
                chunks_for_logging.append((
                    chunk['text'],
                    chunk['source_name'],
                    chunk['source_type'],
                    original_idx
                ))

            query_logger.log_retrieved_chunks(
                username="system",
                session_id=selected_session_id,
                session_name=session_name,
                query=request.question,
                chunks_used=chunks_for_logging,
                remote_ip="localhost",
                similarity_scores=[c['similarity'] for c in relevant_chunks]
            )

        logger.info("=" * 100)
        logger.info("‚úÖ QUESTION ANSWERING COMPLETED SUCCESSFULLY")
        logger.info("=" * 100 + "\n")

        return {
            "status": "success",
            "answer": answer,

            "qa_id": None
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error("\n" + "=" * 100)
        logger.error("‚ùå ERROR IN QUESTION ANSWERING")
        logger.error("=" * 100)
        logger.error(f"Error details: {str(e)}")
        logger.error(f"Error type: {type(e).__name__}")
        import traceback
        logger.error(f"Traceback:\n{traceback.format_exc()}")
        logger.error("=" * 100 + "\n")

        # Log error to QueryLogger
        query_logger.log_query_interaction(
            username="system",
            session_id=request.query_session_id,
            session_name="Unknown",
            query=request.question,
            answer=f"Error: {str(e)}",
            remote_ip="localhost",
            session_metadata={},
            retrieval_stats={},
            sources=[],
            timing_details=query_logger.current_timing_details,
            status="FAILURE"
        )

        raise HTTPException(status_code=500, detail=str(e))


@app.post("/delete_query_session")
async def delete_query_session_endpoint(request: Request):
    """Delete a query session"""
    try:
        body = await request.json()
        query_session_id = body.get('query_session_id')

        if not query_session_id:
            raise HTTPException(status_code=400, detail="query_session_id is required")

        delete_query_session(query_session_id)

        return {"status": "success", "message": "Query session deleted"}

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚úó Error deleting query session: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


if __name__ == "__main__":
    port = 8001
    server_ip = "127.0.0.1"

    initialize_sessions_database()
    initialize_project_sessions()


    print(f"\n{'=' * 70}")
    print(f"GPU Processing Server")
    print(f"{'=' * 70}")
    print(f"‚úì Server Address:      http://{server_ip}:{port}")
    print(f"‚úì Health Check:        http://{server_ip}:{port}/health")
    print(f"‚úì Device:              {device}")
    print(f"‚úì Recordings Dir:      {RECORDINGS_DIR.absolute()}")
    print(f"{'=' * 70}")
    print(f"‚úì Loading AI model... (this may take 1-2 minutes)")
    print(f"{'=' * 70}\n")

    uvicorn.run(app, host=server_ip, port=port)
